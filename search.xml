<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>连分数</title>
      <link href="/2025/02/05/%E8%BF%9E%E5%88%86%E6%95%B0/"/>
      <url>/2025/02/05/%E8%BF%9E%E5%88%86%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="连分数基本概念"><a href="#连分数基本概念" class="headerlink" title="连分数基本概念"></a>连分数基本概念</h1><h2 id="1-简单连分数-Simple-Continued-Fraction"><a href="#1-简单连分数-Simple-Continued-Fraction" class="headerlink" title="1. 简单连分数(Simple Continued Fraction)"></a>1. 简单连分数(Simple Continued Fraction)</h2><p>$$<br>a_0+\frac{1}{a_1+\frac{1}{a_2+\frac{1}{a_3+\frac{1}{…}}}}<br>$$</p><p>$a_0$可以是任意整数，$a_i$是正整数$(i&gt;0)$：部分商（partial quotient）</p><p>可简写为$[a_0,a_1,a_2,a_3,…]$</p><p>例如：</p><p>$$<br>\begin{align}<br>\frac{43}{19} &amp;&#x3D; 2+\frac{1}{3+\frac{1}{1+\frac{1}{4}}}\<br>&amp;&#x3D; [2,3,1,4]<br>\end{align}<br>$$</p><h2 id="2-有限连分数"><a href="#2-有限连分数" class="headerlink" title="2.有限连分数"></a>2.有限连分数</h2><p>简单连分数可以分为有限连分数和无线连分数。</p><p><strong>定理：任何有理数都可以表示成有限连分数；任何有限连分数都是一个有理数。</strong><br>$$<br>Q &#x3D; {\frac{a}{b}|a,b \in Z,b \neq 0}<br>$$</p><p>$$<br>\frac{a}{b}\xrightarrow{\text{欧几里得算法}}[a_0,a_1,…,a_n]<br>$$</p><h3 id="连分数还原成分数"><a href="#连分数还原成分数" class="headerlink" title="连分数还原成分数"></a>连分数还原成分数</h3><p>$[a_0,a_1,…,a_n] &#x3D; [a_0,…,a_m,[a_{m+1},…,a_n]]$连分数叠罗汉的形式。<br>$$<br>\begin{align}<br>[a_0,a_1,…,a_n] &amp;&#x3D; a_0+\frac{1}{a_1+\frac{1}{…+\frac{1}{a_n}}} \<br>&amp;&#x3D; \frac{a_0(a_1+\frac{1}{…+\frac{1}{a_n}})+1}{a_1+\frac{1}{…+\frac{1}{a_n}}}\<br>&amp;&#x3D; \frac{a_0[a_1,…,a_n]+1}{[a_1,…,a_n]}\<br>&amp;&#x3D; \frac{a}{b}<br>\end{align}<br>$$</p><h3 id="有限连分数表示倒数"><a href="#有限连分数表示倒数" class="headerlink" title="有限连分数表示倒数"></a>有限连分数表示倒数</h3><p>例：$\frac{43}{19}$ $\xrightarrow{\text{倒数}}$$\frac{19}{43}$</p><p>$$<br>\begin{align}<br>\frac{19}{43} &amp;&#x3D; \frac{1}{\frac{43}{19}}\<br>&amp;&#x3D;\frac{1}{[2,3,1,4]}\<br>&amp;&#x3D;0+\frac{1}{[2,3,1,4]}\<br>&amp;&#x3D;[0,2,3,1,4]<br>\end{align}<br>$$<br>所以$[2,3,1,4]$的倒数是$[0,2,3,1,4]$</p><p><strong>给定有限连分数$[a_0,a_1,…,a_n]$,求倒数</strong></p><ul><li>如果$a_0 &#x3D; 0$，就把0去掉：$[a_1,…,a_n]$</li><li>如果$a_0 \neq 0$，就在前面补上0：$[0,a_0,a_1,…,a_n]$</li></ul><hr><h1 id="连分数理论"><a href="#连分数理论" class="headerlink" title="连分数理论"></a>连分数理论</h1><p>连分数理论（了解连分数、无穷级数等基本概念，熟悉最佳有理数逼近、循环连分数展开、佩尔方程求解等运算过程）</p><h1 id="连分数逼近"><a href="#连分数逼近" class="headerlink" title="连分数逼近"></a>连分数逼近</h1><p>例题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag[:<span class="built_in">len</span>(flag) // <span class="number">2</span>])</span><br><span class="line">m2 = bytes_to_long(flag[<span class="built_in">len</span>(flag) // <span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">pbits, qbits</span>):</span><br><span class="line">    p1, q1 = getPrime(pbits), getPrime(qbits)</span><br><span class="line">    n1 = p1**<span class="number">4</span>*q1</span><br><span class="line">    q2 = getPrime(qbits)</span><br><span class="line">    bound = p1 // (<span class="number">8</span>*q1*q2) + <span class="number">1</span></span><br><span class="line">    p2 = random.randrange(p1, p1 + bound)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> isPrime(p2):</span><br><span class="line">        p2 = random.randrange(p1, p1 + bound)</span><br><span class="line">    n2 = p2**<span class="number">4</span>*q2</span><br><span class="line">    <span class="keyword">return</span> (n1, n2), (p1, q1), (p2, q2)</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">pbits = <span class="built_in">int</span>(<span class="number">360</span>)</span><br><span class="line">qbits = <span class="built_in">int</span>(<span class="number">128</span>)</span><br><span class="line">pk, sk1, sk2 = gen(pbits, qbits)</span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, pk[<span class="number">0</span>])</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, pk[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;pk = <span class="subst">&#123;pk&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c1, c2 = <span class="subst">&#123;c1, c2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">pk = (1150398070565459492080597718626032792435556703413923483458704675295997646493249759818468321328556510074044954676615760446708253531839417036997811506222349194302791943489195718713797322878586379546657275419261647635859989280700191441312691274285176619391539387875252135478424580680264554294179123254566796890998243909286508189826458854346825493157697201495100628216832191035903848391447704849808577310612723700318670466035077202673373956324725108350230357879374234418393233, 1242678737076048096780023147702514112272319497423818488193557934695583793070332178723043194823444815153743889740338870676093799728875725651036060313223096288606947708155579060628807516053981975820338028456770109640111153719903207363617099371353910243497871090334898522942934052035102902892149792570965804205461900841595290667647854346905445201396273291648968142608158533514391348407631818144116768794595226974831093526512117505486679153727123796834305088741279455621586989)</span></span><br><span class="line"><span class="string">c1, c2 = (361624030197288323178211941746074961985876772079713896964822566468795093475887773853629454653096485450671233584616088768705417987527877166166213574572987732852155320225332020636386698169212072312758052524652761304795529199864805108000796457423822443871436659548626629448170698048984709740274043050729249408577243328282313593461300703078854044587993248807613713896590402657788194264718603549894361488507629356532718775278399264279359256975688280723740017979438505001819438, 33322989148902718763644384246610630825314206644879155585369541624158380990667828419255828083639294898100922608833810585530801931417726134558845725168047585271855248605561256531342703212030641555260907310067120102069499927711242804407691706542428236208695153618955781372741765233319988193384708525251620506966304554054884590718068210659709406626033891748214407992041364462525367373648910810036622684929049996166651416565651803952838857960054689875755131784246099270581394)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密</title>
      <link href="/2025/01/24/RSA%E7%9B%B8%E5%85%B3/"/>
      <url>/2025/01/24/RSA%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="rsa算法"><a href="#rsa算法" class="headerlink" title="rsa算法"></a>rsa算法</h2><p><font style="color:#000000;">模数n&#x3D;p*q</font></p><p><font style="color:#000000;">欧拉数phi&#x3D;(p-1)*(q-1)，当p,q为素数时；phi&#x3D;p^k-p^(k-1)，当n&#x3D;p^k时</font></p><p><font style="color:#000000;">gcd(e,phi)&#x3D;1，即加密钥e和phi互质</font></p><p><font style="color:#000000;">d*e mod phi ，即解密钥d与e互为逆元</font></p><p><font style="color:#000000;">加密c&#x3D;(m^e) mod n &#x3D; pow(m,e,n)</font></p><p><font style="color:#000000;">解密m&#x3D;(c^d) mod n&#x3D; pow(c,d,n)</font></p><p><font style="color:#000000;"></font></p><p><font style="color:#000000;">欧拉定理有：m^phi≡1(mod n)</font></p><p><font style="color:#000000;"></font></p><h2 id="相关运算函数"><a href="#相关运算函数" class="headerlink" title="相关运算函数"></a><font style="color:#000000;">相关运算函数</font></h2><blockquote><p>flag &#x3D; bytes.fromhex(hex(m)[2:])#提取十六进制字符串转换输出</p></blockquote><blockquote><p>str(e1).ljust(20,”D”)#填充字符D，使得字符串左对齐且长度20</p></blockquote><blockquote><p>long_to_bytes(e1_).rstrip(b”D”)#删除字符串末尾（右侧）的指定字符D</p></blockquote><blockquote><p>from Crypto.Util.number import *</p><p>m &#x3D; bytes_to_long(flag)#字符串转换为长整型数字</p><p>flag &#x3D; long_to_bytes(m)#数字转换为字符串</p><p>d &#x3D; inverse(e,phi)#求整数e模phi的逆元</p><p>q&#x3D;GCD(n1,n2)#欧几里得求公因子</p></blockquote><blockquote><p>import libnum</p><p>m &#x3D; libnum.s2n(flag)#字符串转换为int型</p><p>flag &#x3D; libnum.n2s(int(m))#int转换为str型</p></blockquote><blockquote><p>import gmpy2</p><p>d &#x3D; gmpy2.invert(e,phi)#求整数e模phi的逆元</p><p>p &#x3D; gmpy2.gcd(n1,n2) #欧几里得求n1,n2的最大公约数</p><p>g,s1,s2&#x3D; gmpy2.gcdext(e1,e2)#gmpy2.gcdext()扩展欧几里得运算</p><p>x &#x3D; gmpy2.iroot(m,n)[0]   #对m开n次根,返回m的n次方根（整数）和一个布尔数(结果的n次方是否刚好等于原来的数)</p></blockquote><blockquote><p>import rsa#rsa模块</p><p>pubkey &#x3D; rsa.PublicKey.load_pkcs1(key)#传入公钥</p><p>privkey &#x3D; rsa.PrivateKey.load_pkcs1(key)#传入私钥</p><p>crypto &#x3D; rsa.encrypt(message.encode(‘utf-8’), pubkey)#用公钥加密</p><p>message &#x3D; rsa.decrypt(crypto, privkey).decode(‘utf-8’)#用私钥解密</p></blockquote><blockquote><p>from Crypto.PublicKey import RSA</p><p>pubkey &#x3D; RSA.importKey(key) #传入公钥</p><p>n &#x3D; pubkey.n#获取公钥中的n</p><p>e &#x3D; pubkey.e#获取公钥中的e</p></blockquote><blockquote><p><font style="color:#080808;background-color:#ffffff;">from binascii import a2b_hex,b2a_hex</font></p><p><font style="color:#080808;background-color:#ffffff;">m &#x3D; int(b2a_hex(flag),16) #将字节串 flag 转换成十六进制字符串，然后再转换成十进制整数  </font></p><p><font style="color:#080808;background-color:#ffffff;">flag &#x3D; a2b_hex(hex(m)[2:])</font></p></blockquote><h3 id="查找某个数的因子"><a href="#查找某个数的因子" class="headerlink" title="查找某个数的因子"></a>查找某个数的因子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_factors</span>(<span class="params">n</span>):</span><br><span class="line">    factors = []</span><br><span class="line">    <span class="comment"># 只需要遍历到 sqrt(n) 进行因子检查</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:  <span class="comment"># 如果 i 是 n 的因子</span></span><br><span class="line">            factors.append(i)</span><br><span class="line">            <span class="keyword">if</span> i != n // i:  <span class="comment"># 如果 i 和 n//i 不相等，则添加 n//i 作为因子</span></span><br><span class="line">                factors.append(n // i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(factors)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 查找 3087 的因子</span></span><br><span class="line">factors = find_factors(<span class="number">3087</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;factors:&#x27;</span>,factors)</span><br></pre></td></tr></table></figure><h3 id="欧拉数计算"><a href="#欧拉数计算" class="headerlink" title="欧拉数计算"></a>欧拉数计算</h3><p>任何素数p的k次方的欧拉函数为p^k-p^(k-1)  </p><p>n &#x3D; p ** 2 * q ** 3 * r ** 5 * s ** 7</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phi = p*(p-<span class="number">1</span>) * q**<span class="number">2</span>*(q-<span class="number">1</span>)  * r**<span class="number">4</span>*(r-<span class="number">1</span>)  * s**<span class="number">6</span>*(s-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理CRT"><a href="#中国剩余定理CRT" class="headerlink" title="中国剩余定理CRT"></a>中国剩余定理CRT</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># assert e &lt;= 500000</span></span><br><span class="line"><span class="comment"># leak1 = c % q</span></span><br><span class="line"><span class="comment"># leak2 = c % p</span></span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> crt</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">n = <span class="number">21256406304024147327122699985764737895162788854942201173538004689536569610046157311527715126074775927977409773971656249943602454790380966869525211733301201659688694473703188427037879868522859419364680904585572399937639393418586498509580133474303442722716959873727260844993296681950092753897902540593927952622713860163782763263944291810729056735965535138964485886748344167499818148134252327820007439830749462775149754781930983094046362696040641091039506998835624218220892441813224657845627120344960554424765109502415773475619490661527184126374299883610442465428985757004551740482644952396990065188807827114495184096249</span></span><br><span class="line">leak1 = <span class="number">8842431959638543756327530752221031675897458993985909403335303147413741167900365489182674478419510549838159493192002672500346433589707076289344572454304647803237654059883974235710442126617587691632375039292283285577033977676131772115877520248352227419433136507412485140428972344000541898060766721412300525883</span></span><br><span class="line">leak2 = <span class="number">127414092867622693231378230621806169422569654246682818498761930473755998913688181327473434110121174292309611256339271412324673262030535400937563769685033472683498585742711576446343086462569783541192470920638935990937187809422965809986860709074542257475025562691683977493260026623616012846939417988284096473040</span></span><br><span class="line">p = <span class="number">131567902193947737457053703919039608741727165458271604872166212865939087016959861850815713604059268499777293923208600279164674644010570874718551586480430092745439767701977059922316781232716126035386163833756203019774439784605127681828683292496816187253311811505880053923307168541440673933884409766487464694543</span></span><br><span class="line">q = <span class="number">161562249983202700035527081166558786031731223261198195999535987465827171883730733359944156020947215855022510635343983292897557354440470230745496731228302894376018866016596714241754815953745113727125200716224341010140868299262202025976056483744622119807303134689795661748036502596285135565503272596613700276343</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = [crt([p,q],[leak1,leak2])[<span class="number">0</span>],crt([q,p],[leak1,leak2])[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> tqdm.tqdm(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">500001</span>)):</span><br><span class="line">    <span class="keyword">if</span> isPrime(e) <span class="keyword">and</span> GCD(e,phi) == <span class="number">1</span>:</span><br><span class="line">        d = inverse(e,phi)</span><br><span class="line">        flag1 = long_to_bytes(<span class="built_in">pow</span>(c[<span class="number">0</span>],d,n))</span><br><span class="line">        flag2 = long_to_bytes(<span class="built_in">pow</span>(c[<span class="number">1</span>],d,n))</span><br><span class="line">        <span class="keyword">if</span> flag1.startswith(<span class="string">b&#x27;flag&#x27;</span>) <span class="keyword">or</span> flag2.startswith(<span class="string">b&#x27;flag&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(flag1,flag2)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><ul><li>在线分解</li></ul><p><a href="http://factordb.com/"><font style="color:#000000;">http://factordb.com/</font></a></p><p><font style="color:#000000;"></font></p><ul><li>yafu分解</li></ul><p><font style="color:#000000;">进入yafu目录，运行yafu-x64，输入factor()分解命令；</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25907408/1715566461765-cc8347b4-677f-4003-afd2-1cb166ec8711.png"><font style="color:#000000;">若n比较大，可以将大数存在p.txt里面，记得最后要换行再保存，然后再输入命令</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yafu-x64 <span class="string">&quot;factor(@)&quot;</span> -batchfile p.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25907408/1715566461955-101fb1ff-cf70-4ed8-b17d-cb5adbc304c9.png"></p><ul><li><font style="color:#000000;">RSA-Tool工具</font></li></ul><p>[G:\Tools\CTF工具合集-狼组安全\CTF工具合集\编码与密码\密码\RSA\RSA Tool 2 by tE!]</p><h1 id="对n的分解"><a href="#对n的分解" class="headerlink" title="对n的分解"></a>对n的分解</h1><h4 id="工具分解"><a href="#工具分解" class="headerlink" title="工具分解"></a>工具分解</h4><p><font style="color:rgb(0,0,0);">在线分解：</font><a href="http://factordb.com/">http://factordb.com/</a></p><p><font style="color:rgb(0,0,0);">yafu工具分解：</font></p><blockquote><p><font style="color:rgb(0,0,0);">yafu-x64.exe factor(数值)</font></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25907408/1715752650132-b516973b-371a-48fb-a3f0-f0621d94faf5.png">或者<font style="color:rgb(0,0,0);">进入yafu目录，运行yafu-x64，输入factor()分解命令</font></p><p><font style="color:rgb(0,0,0);">若n比较大，可以将大数存在p.txt里面，记得最后要换行再保存，然后再输入命令</font></p><blockquote><p><font style="color:rgb(0,0,0);">yaf</font>u-x64 “factor(@)” -batchfile p.txt</p></blockquote><h4 id="使用xenny库分解"><a href="#使用xenny库分解" class="headerlink" title="使用xenny库分解"></a>使用xenny库分解</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa.factor <span class="keyword">import</span> attack</span><br><span class="line"></span><br><span class="line">h=attack(n)</span><br><span class="line">phi=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> h:</span><br><span class="line">    phi *= (i-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="n为平方数"><a href="#n为平方数" class="headerlink" title="n为平方数"></a>n为平方数</h2><h3 id="例题-2024帕鲁杯-Crypto签到"><a href="#例题-2024帕鲁杯-Crypto签到" class="headerlink" title="例题[2024帕鲁杯]Crypto签到"></a>例题[2024帕鲁杯]Crypto签到</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c: <span class="number">29130338567539642292224345417062682096857319681273251007223801075007117209658328676649064601473308134714791287696851440121630806360278319074292605755418887190185593537712473045214008291410001775930694108013242943848258395135952696552084545291259859231649633261238873250712964264503896336948005025106771373266</span></span><br><span class="line">p: <span class="number">7785114817668195310239911953697076802580827251921698422211982784044402109813961441887588595879409577427293212974989549188783982273190099054212815027653723</span></span><br><span class="line">e: <span class="number">65537</span></span><br><span class="line">n: <span class="number">60608012724276897910243785723631673275322169664021369876126832401363490500241092129622889939967689177576036720101193770910837262717893023290929314900627393024068795070159899357254970398771430201685586974093565495598320921536567333349716079582900320455109956011892245832283502015817961399751338885218395760729</span></span><br></pre></td></tr></table></figure><p>由于n是一个素数的平方数</p><p>$ n&#x3D;p^2 $</p><p>$ p h i &#x3D; n ∗ ( 1 - 1 &#x2F; p ) &#x3D; n − p $</p><p>解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">c = <span class="number">29130338567539642292224345417062682096857319681273251007223801075007117209658328676649064601473308134714791287696851440121630806360278319074292605755418887190185593537712473045214008291410001775930694108013242943848258395135952696552084545291259859231649633261238873250712964264503896336948005025106771373266</span></span><br><span class="line">p = <span class="number">7785114817668195310239911953697076802580827251921698422211982784044402109813961441887588595879409577427293212974989549188783982273190099054212815027653723</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">60608012724276897910243785723631673275322169664021369876126832401363490500241092129622889939967689177576036720101193770910837262717893023290929314900627393024068795070159899357254970398771430201685586974093565495598320921536567333349716079582900320455109956011892245832283502015817961399751338885218395760729</span></span><br><span class="line"></span><br><span class="line">q = n//p</span><br><span class="line"><span class="comment"># print(&quot;q=”,q)</span></span><br><span class="line"><span class="comment"># if p == q:</span></span><br><span class="line"><span class="comment">#   print(&quot;phi=”，p*(p-1))</span></span><br><span class="line"></span><br><span class="line">phi = p*(p-<span class="number">1</span>)</span><br><span class="line">d = invert(e,phi)</span><br><span class="line">m= <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><h2 id="多因子模数n"><a href="#多因子模数n" class="headerlink" title="多因子模数n"></a>多因子模数n</h2><p><font style="color:rgb(0,0,0);">已知n,c,e，分解n存在多个因子，根据积的欧拉函数等于各个因子的欧拉函数之积，计算φ(n)</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#n = p * q * r</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m)) </span><br></pre></td></tr></table></figure><h3 id="例题-第五题：模数N有多个因子"><a href="#例题-第五题：模数N有多个因子" class="headerlink" title="例题-第五题：模数N有多个因子"></a><font style="color:rgb(0,0,0);">例题-第五题：模数N有多个因子</font></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">size = <span class="number">64</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ps = [number.getPrime(size) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(ps)) == n:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = reduce(<span class="keyword">lambda</span> x, y: x*y, ps)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br></pre></td></tr></table></figure><p>题目中，循环生成了一个五元组ps</p><p>n &#x3D; reduce(lambda x, y: x*y, ps)</p><ul><li>reduce(function,iterable)对参数iterable进行function累积操作</li><li>lambda匿名函数，在 lambda 关键字之后、冒号左边为参数列表，可不带参数，也可有多个参数。若有多个参数，则参数间用逗号隔开，冒号右边为 lambda 表达式的返回值。</li></ul><p>因此n为ps里面元素的乘积n&#x3D;ps[1]∗ps[2]∗ps[3]∗ps[4]∗ps[5]&#x3D;P1∗P2∗P3∗P4∗P5</p><p>欧拉函数 φ(n) 的定义是小于等于 n 的正整数中与 n 互素的数的个数。根据定理：积的欧拉函数等于各个因子的欧拉函数之积，有：</p><p>φ(n)&#x3D;φ(P1<em>P2</em>P3<em>P4</em>P5)&#x3D;φ(P1)<em>φ(P2)<em>φ(P3)<em>φ(P4)<em>φ(P5)&#x3D;(P1-1)</em>(P2-1)</em>(P3-1)</em>(P4-1)</em>(P5-1)</p><h2 id="pq相近（先尝试费马分解）"><a href="#pq相近（先尝试费马分解）" class="headerlink" title="pq相近（先尝试费马分解）"></a>pq相近（先尝试费马分解）</h2><p>p&#x3D;getPrime(512)，q&#x3D;gmpy2.next_prime(p)，n&#x3D;p*q，已知n,c,e求解</p><h4 id="方式一：yafu分解"><a href="#方式一：yafu分解" class="headerlink" title="方式一：yafu分解"></a>方式一：yafu分解</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yafu-x64.exe factor(<span class="number">67404963224397872004829149318925148075434117618824834322328416628280743741428791288300796542317495894790227314895907628516568882213137327332742751337518574639189137375898709557561684474330258193244895126089812520799969059971430323123121550971117086675629700542873484683090602611092439306191635422655827463087</span>)</span><br></pre></td></tr></table></figure><p>分解原理：p，q是两个素数，而且他俩在素数序列里面就是一前一后的关系。所以他俩的乘积开根号得到的结果一定是在p，q之间的一个数字，（而且一定不是素数，因为p，q就是紧邻的两个素数）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp=gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]  <span class="comment">#对n开平方。gmpy2的iroot函数，这个函数专门用来进行大数开根号，gmpy2.iroot(n,t)。n就是大整数，t是开几次幂。</span></span><br><span class="line">p=gmpy2.next_prime(temp)</span><br><span class="line">q=n//p</span><br></pre></td></tr></table></figure><h4 id="方式二：平方差遍历"><a href="#方式二：平方差遍历" class="headerlink" title="方式二：平方差遍历"></a>方式二：平方差遍历</h4><p>令a是n的”中间值”（$ \sqrt{n} $)，然后让a以步长为1自增遍历，直到pow(a,2)-n的结果可以正好开方为止，那个结果开方就是b。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:   <span class="comment">#破解出来一组就行了，一般也就一组，挨得很近的话很快就出来了，如果长时间还没出来就可以换方法了，不要指望着他遍历所有的，到死也弄不完。</span></span><br><span class="line">    B2=<span class="built_in">pow</span>(a,<span class="number">2</span>)-n</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_square(B2):</span><br><span class="line">        b=gmpy2.iroot(B2,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        p=a+b</span><br><span class="line">        q=a-b</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;p=&quot;</span>,p,<span class="string">&quot;\nq=&quot;</span>,q)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/hacker_zrq/article/details/121444869">https://blog.csdn.net/hacker_zrq&#x2F;article&#x2F;details&#x2F;121444869</a></p><h4 id="方式三：费马分解"><a href="#方式三：费马分解" class="headerlink" title="方式三：费马分解"></a>方式三：费马分解</h4><p>费马分解的原理：</p><p>$ \frac{(p+q)^2​}{4}−n&#x3D;\frac{(p+q)^2​}{4}​−pq&#x3D;\frac{(p-q)^2​}{4} $</p><details class="lake-collapse"><summary id="u8af5881e"><span class="ne-text">计算原理：</span></summary><p id="uc0e0cd1d" class="ne-p"><span class="ne-text"> 对于任一个奇数n，n = ab = x</span><sup><span class="ne-text">2</span></sup><span class="ne-text">-y</span><sup><span class="ne-text">2</span></sup><span class="ne-text"> 。</span></p><p id="u08e3bd2a" class="ne-p"><strong><span class="ne-text">1&gt; y</span></strong><sup><strong><span class="ne-text">2</span></strong></sup><strong><span class="ne-text"> = x</span></strong><sup><strong><span class="ne-text">2</span></strong></sup><strong><span class="ne-text"> – n</span></strong></p><p id="ub00332c5" class="ne-p"><span class="ne-text">∵ x</span><sup><span class="ne-text">2</span></sup><span class="ne-text"> – n &gt;= y</span><sup><span class="ne-text">2</span></sup><span class="ne-text"> &gt;= 0</span></p><p id="u82df50e3" class="ne-p"><span class="ne-text">∴x</span><sup><span class="ne-text">2</span></sup><span class="ne-text"> &gt;= n, x &gt;= sqrt(n)</span></p><p id="u57882990" class="ne-p"><span class="ne-text">∴我们可以从x = sqrt(n)开始，计算x</span><sup><span class="ne-text">2</span></sup><span class="ne-text"> – n为完全平方数即可求出x, y，然后求得a, b。</span></p></details><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#费马分解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fermat</span>(<span class="params">n</span>):</span><br><span class="line">    x = gmpy2.iroot(n, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> x * x &lt; n:</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># y^2 = x^2 - num</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        y2 = x * x - n;</span><br><span class="line">        y = gmpy2.iroot(y2, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> y * y == y2:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [x + y, x - y];</span><br><span class="line">p,q = Fermat(n)</span><br></pre></td></tr></table></figure><h1 id="经典题型"><a href="#经典题型" class="headerlink" title="经典题型"></a>经典题型</h1><h3 id="爆破e"><a href="#爆破e" class="headerlink" title="爆破e"></a><font style="color:#080808;background-color:#ffffff;">爆破e</font></h3><h4 id="1-已知p-q-c-n爆破e"><a href="#1-已知p-q-c-n爆破e" class="headerlink" title="1.已知p,q,c,n爆破e"></a>1.已知p,q,c,n爆破e</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p =<span class="number">842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569</span></span><br><span class="line">q = <span class="number">139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183</span></span><br><span class="line">n =  <span class="number">117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127</span></span><br><span class="line">c =  <span class="number">41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128</span></span><br><span class="line"></span><br><span class="line">phi =(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">70000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        d = gmpy2.invert(e, phi)</span><br><span class="line">        flag = gmpy2.powmod(c, d, n)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;CTF&#x27;</span> <span class="keyword">in</span> long_to_bytes(flag):</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(flag))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#b&#x27;RoarCTF&#123;wm-l1l1ll1l1l1l111ll&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-已知c-m-p-q爆破指数e"><a href="#2-已知c-m-p-q爆破指数e" class="headerlink" title="2.已知c,m,p,q爆破指数e"></a><font style="color:#080808;background-color:#ffffff;">2.已知c,m,p,q爆破指数e</font></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#已知c,m,p,q爆破指数e</span></span><br><span class="line">m = bytes_to_long(<span class="string">b&quot;BJD&quot;</span> * <span class="number">32</span>)</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">65537</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(m, e, n) == c:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Found e: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="3-m1-c1-m2-c2-n1-n2爆破e"><a href="#3-m1-c1-m2-c2-n1-n2爆破e" class="headerlink" title="3.m1,c1,m2,c2,n1,n2爆破e"></a>3.m1,c1,m2,c2,n1,n2爆破e</h4><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"></span><br><span class="line">flag=<span class="built_in">open</span>(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">assert</span>(e&lt;<span class="number">100000</span>)</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span> c,n</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(<span class="number">294</span>,e,n)</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(<span class="string">&quot;BJD&quot;</span>*<span class="number">32</span>)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span> c,n</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120  13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line"><span class="string">381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018</span></span><br><span class="line"><span class="string">979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721  12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>已知m1,c1,n1,m2,c2,n2，且c1,c2存在公因子q</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c,n = <span class="number">12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120</span>,<span class="number">13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037</span></span><br><span class="line"><span class="comment">#c1 = pow(294,e,n)</span></span><br><span class="line">c1 = <span class="number">381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018</span></span><br><span class="line">n1 = n</span><br><span class="line">m2 = bytes_to_long((<span class="string">&quot;BJD&quot;</span> * <span class="number">32</span>).encode())</span><br><span class="line">c2,n2 = <span class="number">979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721</span>,<span class="number">12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047</span></span><br><span class="line"></span><br><span class="line">q=GCD(n1,n2)</span><br><span class="line">p1=n1//q</span><br><span class="line"><span class="keyword">assert</span> p1*q==n1</span><br><span class="line">p2=n2//q</span><br><span class="line"><span class="keyword">assert</span> p2*q==n2</span><br><span class="line"><span class="comment">#根据已知信息爆破e</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> c2==<span class="built_in">pow</span>(m2,i,n2) <span class="keyword">and</span> c1==<span class="built_in">pow</span>(<span class="number">294</span>,i,n1):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;e爆破成功：&quot;</span>,i)</span><br><span class="line">        e=i</span><br><span class="line"><span class="comment">#解得flag</span></span><br><span class="line">phi=(p1-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">flag=<span class="built_in">pow</span>(c,d,n1)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br><span class="line"><span class="comment"># e爆破成功：52361</span></span><br><span class="line"><span class="comment"># b&#x27;BJD&#123;p_is_common_divisor&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;c=&#x27;</span>, <span class="string">&#x27;0x7a7e031f14f6b6c3292d11a41161d2491ce8bcdc67ef1baa9eL&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;e=&#x27;</span>, <span class="string">&#x27;0x872a335&#x27;</span>)</span><br><span class="line"><span class="comment">#q + q*p^3 =1285367317452089980789441829580397855321901891350429414413655782431779727560841427444135440068248152908241981758331600586</span></span><br><span class="line"><span class="comment">#qp + q *p^2 = 1109691832903289208389283296592510864729403914873734836011311325874120780079555500202475594</span></span><br></pre></td></tr></table></figure><p>列方程解出p、q的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment">#x = q + q*p^3 </span></span><br><span class="line">x=<span class="number">1285367317452089980789441829580397855321901891350429414413655782431779727560841427444135440068248152908241981758331600586</span></span><br><span class="line"><span class="comment">#y = qp + q *p^2 </span></span><br><span class="line">y= <span class="number">1109691832903289208389283296592510864729403914873734836011311325874120780079555500202475594</span></span><br><span class="line"></span><br><span class="line">p,q = symbols(<span class="string">&#x27;p,q&#x27;</span>)</span><br><span class="line">eq1=Eq(q+q*<span class="built_in">pow</span>(p,<span class="number">3</span>), x)</span><br><span class="line">eq2=Eq(q*p+q*<span class="built_in">pow</span>(p,<span class="number">2</span>), y)</span><br><span class="line">s = solve((eq1,eq2),(p,q))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#(1158310153629932205401500375817, 827089796345539312201480770649)</span></span><br></pre></td></tr></table></figure><h4 id="例题-BJDCTF-2020-EasyRSA"><a href="#例题-BJDCTF-2020-EasyRSA" class="headerlink" title="例题 [BJDCTF 2020]EasyRSA"></a>例题 [BJDCTF 2020]EasyRSA</h4><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> Derivative</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=p*q</span><br><span class="line">z=Fraction(<span class="number">1</span>,Derivative(arctan(p),p))-Fraction(<span class="number">1</span>,Derivative(arth(q),q))</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c,z,n)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035</span></span><br><span class="line"><span class="string">32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482</span></span><br><span class="line"><span class="string">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>关键思路在于怎么去处理<code>z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q))</code></li><li><code>Fraction(a, b)</code> 表示分数$ a&#x2F;b $，而 <code>Derivative(f, x)</code> 表示函数$  f(x) $对$ x $的导数</li></ul><p>&#x3D;&#x3D;&gt;<img src="https://cdn.nlark.com/yuque/0/2025/png/25907408/1736304885091-6523ad8e-8857-4a0b-95c4-342e7a15ea9a.png"></p><ul><li>arctan( p ): 这是反正切函数</li><li>Derivative(arctan( p ),p)：这是给arctan( p )关于p求导，结果是$ 1&#x2F;(1+p^2) $</li></ul><p>&#x3D;&#x3D;&gt;<img src="https://cdn.nlark.com/yuque/0/2025/png/25907408/1736304944328-7bd0921f-16a9-40b1-84ef-d5864a631285.png"></p><ul><li>Fraction(1,Derivative(arctan(p),p))：即一个分数，分子是第一个数，分母是第二个数，即$ 1+p^2 $</li></ul><p>&#x3D;&#x3D;&gt;<img src="https://cdn.nlark.com/yuque/0/2025/png/25907408/1736305014700-d53d24bb-81a3-4df6-b691-e3ca719c8d82.png"></p><ul><li>arth(q): 这个函数不太常见，但在数学中，这通常表示双曲正切的反函数，它求导是$ 1&#x2F;(1-q^2) $</li></ul><p><code>arth(q)</code>是反双曲正切函数，即 $ arth(q)&#x3D;artanh(q) $</p><p>  &#x3D;&#x3D;&gt;<img src="https://cdn.nlark.com/yuque/0/2025/png/25907408/1736305095256-041fcad2-fa6e-4fbd-b885-69ac91b293e4.png"></p><ul><li>Fraction(1,Derivative(arth(q),q))即$ 1-q^2 $</li></ul><p>&#x3D;&#x3D;&gt;<img src="https://cdn.nlark.com/yuque/0/2025/png/25907408/1736305119042-3b9811f8-5b2b-48ec-9d2a-5173ccd19e0f.png"></p><ul><li>两者做差后即$ z &#x3D; p^2+q^2 $</li></ul><p>解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, solve</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">c = <span class="number">7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035</span></span><br><span class="line">z = <span class="number">32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482</span></span><br><span class="line">n = <span class="number">15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列方程求解</span></span><br><span class="line">p, q = symbols(<span class="string">&#x27;p q&#x27;</span>)</span><br><span class="line">const1 = p**<span class="number">2</span>+q**<span class="number">2</span> -z</span><br><span class="line">const2 = p*q -n</span><br><span class="line">solutions = solve((const1,const2),(p,q))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,solution <span class="keyword">in</span> <span class="built_in">enumerate</span>(solutions,<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Solution <span class="subst">&#123;i&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;p: <span class="subst">&#123;solution[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;q: <span class="subst">&#123;solution[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="number">105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141</span></span><br><span class="line">q = <span class="number">144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#b&#x27;BJD&#123;Advanced_mathematics_is_too_hard!!!&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="例题-黑盾杯-2020-Factor"><a href="#例题-黑盾杯-2020-Factor" class="headerlink" title="例题 [黑盾杯 2020]Factor"></a>例题 [黑盾杯 2020]Factor</h4><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">3454083680130687060405946528826790951695785465926614724373</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">1347530713288996422676156069761604101177635382955634367208</span></span><br><span class="line">gcd(m, n) = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>解题脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="keyword">import</span> factor</span><br><span class="line">n = <span class="number">3454083680130687060405946528826790951695785465926614724373</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">1347530713288996422676156069761604101177635382955634367208</span></span><br><span class="line">p = factor.attack(n)</span><br><span class="line">phi = <span class="number">1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    <span class="keyword">if</span> GCD(e, i-<span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">        phi *= i-<span class="number">1</span></span><br><span class="line">        n *= i</span><br><span class="line"></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))</span><br><span class="line"><span class="string">b&#x27;CMISCCTF&#123;3_RSA&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="e与phi不互素"><a href="#e与phi不互素" class="headerlink" title="e与phi不互素"></a>e与phi不互素</h3><p>情况一：公因子小</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = GCD(e,phi)</span><br><span class="line">d = inverse(e//t,phi)</span><br><span class="line">m_t = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">m = gmpy2.iroot(m_2,t)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>情况二：e和phi的公因数为e</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br><span class="line">q = 9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br><span class="line">r = 102909133680612532601801231903654039</span><br><span class="line">e = 65537</span><br><span class="line">c = 142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><span class="line">n = p*q*r</span><br><span class="line">phi=(p-1)*(q-1)*(r-1)</span><br><span class="line"># d = inverse(e,phi)</span><br><span class="line">t = gmpy2.gcd(e,phi)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">#e和phi的公因数为e</span><br><span class="line"># 猜测flag很短,模p域下解</span><br><span class="line">d = inverse(e,p-1)</span><br><span class="line">m = pow(c,d,p)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h4 id="例题-LitCTF-2023-e的学问"><a href="#例题-LitCTF-2023-e的学问" class="headerlink" title="例题[LitCTF 2023]e的学问"></a>例题[LitCTF 2023]e的学问</h4><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">m=bytes_to_long(<span class="string">b&#x27;xxxxxx&#x27;</span>)</span><br><span class="line">p=getPrime(<span class="number">256</span>)</span><br><span class="line">q=getPrime(<span class="number">256</span>)</span><br><span class="line">e=<span class="number">74</span></span><br><span class="line">n=p*q</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p=&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q=&quot;</span>,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="comment">#p= 86053582917386343422567174764040471033234388106968488834872953625339458483149</span></span><br><span class="line"><span class="comment">#q= 72031998384560188060716696553519973198388628004850270102102972862328770104493</span></span><br><span class="line"><span class="comment">#c= 3939634105073614197573473825268995321781553470182462454724181094897309933627076266632153551522332244941496491385911139566998817961371516587764621395810123</span></span><br></pre></td></tr></table></figure><p>解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p= <span class="number">86053582917386343422567174764040471033234388106968488834872953625339458483149</span></span><br><span class="line">q= <span class="number">72031998384560188060716696553519973198388628004850270102102972862328770104493</span></span><br><span class="line">c= <span class="number">3939634105073614197573473825268995321781553470182462454724181094897309933627076266632153551522332244941496491385911139566998817961371516587764621395810123</span></span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">e= <span class="number">74</span></span><br><span class="line">t = GCD(e,phi)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line">d = inverse(e//t,phi)</span><br><span class="line">m_2 = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">m = gmpy2.iroot(m_2,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#b&#x27;LitCTF&#123;e_1s_n0t_@_Prime&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h4 id="例题-LitCTF-2023-Euler"><a href="#例题-LitCTF-2023-Euler" class="headerlink" title="例题 [LitCTF 2023]Euler"></a>例题 [LitCTF 2023]Euler</h4><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="built_in">pow</span>(m,n-p-q+<span class="number">3</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 115140122725890943990475192890188343698762004010330526468754961357872096040956340092062274481843042907652320664917728267982409212988849109825729150839069369465433531269728824368749655421846730162477193420534803525810831025762500375845466064264837531992986534097821734242082950392892529951104643690838773406549</span></span><br><span class="line"><span class="string">c = 406480424882876909664869928877322864482740577681292497936198951316587691545267772748204383995815523935005725558478033908575228532559165174398668885819826720515607326399097899572022020453298441</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>phi&#x3D;(p-1)*(q-1)&#x3D;n-p-q+1</p><p>c&#x3D;m^(n-p-q+3) mod n&#x3D;m^(phi+2) mod n&#x3D;(m^phi mod n)*(m^2 mod n)</p><p>由欧拉定理可知 m^phi≡1(mod n)</p><p>则c&#x3D;m^2 mod n&#x3D;pow(m,2,n)</p><h2 id="1）共模攻击"><a href="#1）共模攻击" class="headerlink" title="1）共模攻击"></a>1）共模攻击</h2><p>n值固定，使用不同的e加密同一个m，已知n,c1,c2,e1,e2。</p><p>c1&#x3D;pow(m,e1,n)</p><p>c2&#x3D;pow(m,e2,n)</p><h3 id="解密思路"><a href="#解密思路" class="headerlink" title="解密思路"></a>解密思路</h3><p><font style="color:rgb(0,0,0);">共模攻击：</font></p><p><font style="color:rgb(0,0,0);">根据扩展欧几里得算法可以得到一组整数(s1,s2)，使得：</font>g,s1,s2&#x3D; gmpy2.gcdext(e1,e2)</p><p><font style="color:rgb(0,0,0);">解密明文：</font>m &#x3D; pow(c1,s1,n)*pow(c2,s2,n)%n</p><p><font style="color:rgb(0,0,0);">若e1,e2存在最大公约数g，对m进行开g次方根：m &#x3D; gmpy2.iroot(m,g)[0]</font></p><p>若gcd(e1,e2)&#x3D;1<font style="color:rgb(0,0,0);">，</font>则m &#x3D; pow(c1,s1,n)*pow(c2,s2,n)%n</p><p>最后处理m:flag&#x3D;libnum.n2s(int(m))</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1=<span class="number">12321</span></span><br><span class="line">e2=<span class="number">65535</span></span><br><span class="line">n = n1 = n2</span><br><span class="line">g,s1,s2= gmpy2.gcdext(e1,e2)    <span class="comment">#gmpy2.gcdext()扩展欧几里得运算</span></span><br><span class="line">m = <span class="built_in">pow</span>(c1,s1,n)*<span class="built_in">pow</span>(c2,s2,n)%n</span><br><span class="line">m = gmpy2.iroot(m,g)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag=&quot;</span>,long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-BUUCTF-RSA3"><a href="#例题-BUUCTF-RSA3" class="headerlink" title="例题 BUUCTF[RSA3]"></a>例题 BUUCTF[RSA3]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c1=<span class="number">22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361</span></span><br><span class="line">n=<span class="number">22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801</span></span><br><span class="line">e1=<span class="number">11187289</span></span><br><span class="line">c2=<span class="number">18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397</span></span><br><span class="line">e2=<span class="number">9647291</span></span><br><span class="line"></span><br><span class="line">g, s1, s2 = gcdext(e1, e2)</span><br><span class="line">m = <span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n) % n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;</span></span><br></pre></td></tr></table></figure><h3 id="例题-NSSRound-11-Basic-MyGame"><a href="#例题-NSSRound-11-Basic-MyGame" class="headerlink" title="例题[NSSRound#11 Basic]MyGame"></a>例题[NSSRound#11 Basic]MyGame</h3><ul><li>题目：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">flag = os.getenv(<span class="string">&#x27;FLAG&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;=---menu---=</span></span><br><span class="line"><span class="string">1. Guess</span></span><br><span class="line"><span class="string">2. Encrypt</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randommsg</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choices(string.ascii_lowercase+string.digits, k=<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">mymsg = randommsg()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess</span>():</span><br><span class="line">    <span class="keyword">global</span> mymsg</span><br><span class="line">    msg = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> msg == mymsg:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(mymsg)</span><br><span class="line">        mymsg = randommsg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>():</span><br><span class="line">    e = random.getrandbits(<span class="number">8</span>)</span><br><span class="line">    c = <span class="built_in">pow</span>(bytes_to_long(mymsg.encode()), e, n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Cipher_<span class="subst">&#123;e&#125;</span>: <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;n: <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        opt = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> opt == <span class="number">1</span>:</span><br><span class="line">            guess()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">2</span>:</span><br><span class="line">            encrypt()</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>发现每次连接n的值都在变化</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25907408/1714455868158-176858a5-3239-444c-8da7-cd7cdafc8d36.png"></p><ul><li>解题：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii, gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------ 交互部分 ------------</span></span><br><span class="line">host = <span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span></span><br><span class="line">port = <span class="number">28764</span></span><br><span class="line">conn = remote(host, port)</span><br><span class="line">data1 = conn.recvline().decode()</span><br><span class="line">n = <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;n: (\d+)&#x27;</span>, data1)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interact_with_server</span>(<span class="params">conn</span>):</span><br><span class="line">    conn.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    data1 = conn.recvline().decode()</span><br><span class="line">    <span class="built_in">print</span>(data1)</span><br><span class="line">    e, c = re.findall(<span class="string">r&#x27;Cipher_(\d+): (\d+)&#x27;</span>, data1)[<span class="number">0</span>]</span><br><span class="line">    e = <span class="built_in">int</span>(e)</span><br><span class="line">    c = <span class="built_in">int</span>(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e, c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------ 共模攻击 ------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>():</span><br><span class="line">    e1, c1 = interact_with_server(conn)</span><br><span class="line">    e2, c2 = interact_with_server(conn)</span><br><span class="line"></span><br><span class="line">    g, x, y = gcdext(e1, e2)</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">pow</span>(c1, x, n) * <span class="built_in">pow</span>(c2, y, n) % n</span><br><span class="line"></span><br><span class="line">    m = iroot(m, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_flag</span>():</span><br><span class="line">    m = attack()</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    conn.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    conn.sendline(m)</span><br><span class="line">    <span class="keyword">return</span> conn.recvline().decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    flag = get_flag()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;NSS&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># NSSCTF&#123;86ac589a-108f-4e77-9950-f8a36484056d&#125;</span></span><br></pre></td></tr></table></figure><h3 id="例题-第四题：求解幂运算"><a href="#例题-第四题：求解幂运算" class="headerlink" title="例题-第四题：求解幂运算"></a>例题-第四题：求解幂运算</h3><ul><li>题目</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ec1=<span class="built_in">pow</span>(bytes_to_long(<span class="built_in">str</span>(e1).ljust(<span class="number">20</span>,<span class="string">&quot;D&quot;</span>).encode()),<span class="number">3</span>,p*q)</span><br><span class="line">ec2=<span class="built_in">pow</span>(bytes_to_long(<span class="built_in">str</span>(e2).ljust(<span class="number">20</span>,<span class="string">&quot;A&quot;</span>).encode()),<span class="number">5</span>,p*q)</span><br></pre></td></tr></table></figure><p>对e1填充格式后进行3次幂运算,模n；对e2填充格式后进行5次幂运算,模n</p><ul><li>解题思路：开次方根</li></ul><p>使用gmpy2库中的iroot函数计算ec1的立方根：</p><p>x &#x3D; gmpy2.iroot(ec1,3)[0]</p><p>判断开跟号的结果：</p><p>if pow(x,y,z) &#x3D;&#x3D; r:</p><pre><code>    return x</code></pre><p>即得到e1的填充字符串x</p><p>同理对ec2开5次方运算得到e2的填充字符串</p><p>最后处理填充字符：</p><p>e1 &#x3D; long_to_bytes(x).rstrip(b”D”).decode()</p><p>#ljust()函数是左对齐，并使用指定字符（默认空格）填充至指定长度，同理有rjust()右对齐和center()文本居中对齐；</p><p>#rstrip() 删除 string 字符串末尾的指定字符（不填参数默认为空格符），同理有lstrip()删除开头指定字符，strip()进行左右两侧去空格操作。</p><h3 id="例题-第四题：共模攻击"><a href="#例题-第四题：共模攻击" class="headerlink" title="例题-第四题：共模攻击"></a>例题-第四题：共模攻击</h3><p>已知n,c1,c2,e1,e2，共模攻击即用两个及以上的公钥(n,e)来加密同一条信息m</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=libnum.s2n(flag)</span><br><span class="line">n=p*q</span><br><span class="line">c1=<span class="built_in">pow</span>(m,e1,n)</span><br><span class="line">c2=<span class="built_in">pow</span>(m,e2,n)</span><br></pre></td></tr></table></figure><p>共模攻击：</p><p>根据扩展欧几里得算法可以得到一组整数(s1,s2)，使得 :</p><p>g,s1,s2&#x3D; gmpy2.gcdext(e1,e2)</p><p>解密明文：</p><p>m &#x3D; pow(c1,s1,n)*pow(c2,s2,n)%n</p><p>由于本题中的e1,e2存在最大公约数g&#x3D;3，对m进行开g次方根：</p><p>m &#x3D; gmpy2.iroot(m,g)[0]</p><p>若，则m &#x3D; pow(c1,s1,n)*pow(c2,s2,n)%n</p><p>最后处理m:</p><p>flag&#x3D;libnum.n2s(int(m))</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="2）共享素数"><a href="#2）共享素数" class="headerlink" title="2）共享素数"></a>2）共享素数</h2><p>e值固定，使用不同的n加密，已知e,n1,n2,c1,c2</p><p>c1 &#x3D; pow(m,e,n1)</p><p>c2 &#x3D; pow(m,e,n2)</p><h3 id="解题思路：欧几里得计算最大公约数"><a href="#解题思路：欧几里得计算最大公约数" class="headerlink" title="解题思路：欧几里得计算最大公约数"></a>解题思路：欧几里得计算最大公约数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1 = q*p</span><br><span class="line">n2 = q*r</span><br><span class="line">e = <span class="number">65535</span></span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e,n1)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e,n2)</span><br></pre></td></tr></table></figure><p><font style="color:rgb(0,0,0);">先计算p和q：</font></p><p><font style="color:rgb(0,0,0);">两次公钥的加密过程中使用的</font><font style="color:rgb(0,0,0);">n1和n2具有相同的素因子，则可以利用欧几里得算法直接将n1和n2分解</font><font style="color:rgb(0,0,0);">：</font></p><p><font style="color:rgb(0,0,0);">p &#x3D; gmpy2.gcd(n1,n2)   #gmpy2库函数gcd(),用于求最大公约数</font></p><p><font style="color:rgb(0,0,0);">q &#x3D; n1 &#x2F;&#x2F; p</font></p><p><font style="color:rgb(0,0,0);">然后计算私钥</font><font style="color:rgb(0,0,0);">d:</font></p><p><font style="color:rgb(0,0,0);">phi &#x3D; (p-1)*(q-1)</font></p><p><font style="color:rgb(0,0,0);">d &#x3D; gmpy2.invert(e,phi) #invert是求乘法逆元</font></p><p><font style="color:rgb(0,0,0);">最后</font><font style="color:rgb(0,0,0);">解密密文</font></p><p><font style="color:rgb(0,0,0);">m &#x3D; pow(c1,d,n1)</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = </span><br><span class="line">n1 = </span><br><span class="line">c1 = </span><br><span class="line">n2 = </span><br><span class="line">c2 =</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = gmpy2.gcd(n1,n2)</span><br><span class="line">q = n1 // p</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c1,d,n1)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-闽盾杯-2021-decode"><a href="#例题-闽盾杯-2021-decode" class="headerlink" title="例题 [闽盾杯 2021]decode"></a>例题 [闽盾杯 2021]decode</h3><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1:</span><br><span class="line"><span class="number">15228664629164509105936278301396170708905691970126305196584505186788860519598413718493859625462561931380632032431490419378905593909771649295663481782473029836321132574188559245931660756414915507930357509270674460219615256962333464689419869130366867401404262606367700782040693275068101244535880649261286041921882470460606034302142183971677715439862839410834231609821777031530457674591868138859358815039755085358568037032478394036448363183057305077227769673701227083943898736796552550712057417053897722979700329662099072959306298177351997084389916443815546425080826441671985030755256185725913397986385179516049927425591</span></span><br><span class="line">n2:</span><br><span class="line"><span class="number">28182418532443955655250943929828439725377604572088962537896240628709829618999901367131159759359513146864646169253348651905865895468151210748207509325666501438590382812326109260537618829438786609626137074778638549998280533912080708785604673270460635181275360847313985764185991865570533815651261638439461846512012164531330949433517277559149828806588070421852157781670188281908625986974579194819272643409859915715455134433970119584552350648013116998668938513347083566970423327936691885137812528912263666957628197241313496232397910546498542303925205356813548741679943691886217742767778075067797422624969714343428365022749</span></span><br><span class="line">n3:</span><br><span class="line"><span class="number">18355811159408154065817199279776805621878757240392366715869421799780946779485225342662736231980532326015283372375030686507311099745671828649419794838611580909610100636296701054995302819692794479292794716441442731393027118795245239019609474743841061251498233337758043553376098591254587406941205804917663153256036922860462415387926973551020540123742773938055950168965005226319984869124543783579240130888344231027912143592472823564266887957101575622993773291455143915263715932280728961208233983782906070719786115187115449430196335973764600533097718947377609348244073036523422892353195107093782201003551217830556519184839</span></span><br><span class="line">e1:</span><br><span class="line"><span class="number">65537</span></span><br><span class="line">e2:</span><br><span class="line"><span class="number">27751</span></span><br><span class="line">e3:</span><br><span class="line"><span class="number">65537</span></span><br><span class="line">c1:</span><br><span class="line"><span class="number">5368342382489380107251269030258282008067103595899117880173297169710980852124379736420135829984131832023988667774795223808420069001078159756328642298736759964890517323144475742861501409284299556459601222657540302786301791897975932176538612601162552795835603779910738886150925504885639254302406755008796950704938463132687940418772021406619622090999564746948113296328739593309200238996686945891130656599419832796482095787039339269564880847130379179831744694000940207887150388411084465949903406848727641093033681144598595895383689139227400553234701993087147186292040330589331703587405822925483701667354935313494938769206</span></span><br><span class="line">c2:</span><br><span class="line"><span class="number">21521672635651854919517759696514027081496995002884626306313384597771682621826437868933822942195279941318573525337109548152966094293276717095298929811895186384560362917891928656637913236676702009205642367801075592458101830488916914437754803979953027152373619293870115731171449223105986403604973873007338969000153480949617700626516389419935352576014084068271819009465242491467427642787306345049280205827574043586767133396458785487959251540831856187380154825027964867977651727983254127239427622549059938701125498520279503972702883327594442747467858234391945790597844344295786118320620376681461727686876948563884520137741</span></span><br><span class="line">c3:</span><br><span class="line"><span class="number">13940747781246179701167820858098775936269078279837839169409057305686612176371099274767269714494905207551971162649902129137425806839867713157472497469542260664882313041602553845621113546259276402534229231780532278276697961222319054833980226978574905974878218905613341365260453461080117407529132948986104191917111000811731784483944945364091757083949827612260904757837644538366763161154611658652020868326985526984718638276184626634240096213703958275241215175054246685206226179114590838833694648062135027841593419815101363262701960507235056752424778384286627997500871204804629047307688466887868894491042058198480775705486</span></span><br></pre></td></tr></table></figure><p>解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1=<span class="number">15228664629164509105936278301396170708905691970126305196584505186788860519598413718493859625462561931380632032431490419378905593909771649295663481782473029836321132574188559245931660756414915507930357509270674460219615256962333464689419869130366867401404262606367700782040693275068101244535880649261286041921882470460606034302142183971677715439862839410834231609821777031530457674591868138859358815039755085358568037032478394036448363183057305077227769673701227083943898736796552550712057417053897722979700329662099072959306298177351997084389916443815546425080826441671985030755256185725913397986385179516049927425591</span></span><br><span class="line">n2=<span class="number">28182418532443955655250943929828439725377604572088962537896240628709829618999901367131159759359513146864646169253348651905865895468151210748207509325666501438590382812326109260537618829438786609626137074778638549998280533912080708785604673270460635181275360847313985764185991865570533815651261638439461846512012164531330949433517277559149828806588070421852157781670188281908625986974579194819272643409859915715455134433970119584552350648013116998668938513347083566970423327936691885137812528912263666957628197241313496232397910546498542303925205356813548741679943691886217742767778075067797422624969714343428365022749</span></span><br><span class="line">n3=<span class="number">18355811159408154065817199279776805621878757240392366715869421799780946779485225342662736231980532326015283372375030686507311099745671828649419794838611580909610100636296701054995302819692794479292794716441442731393027118795245239019609474743841061251498233337758043553376098591254587406941205804917663153256036922860462415387926973551020540123742773938055950168965005226319984869124543783579240130888344231027912143592472823564266887957101575622993773291455143915263715932280728961208233983782906070719786115187115449430196335973764600533097718947377609348244073036523422892353195107093782201003551217830556519184839</span></span><br><span class="line">e1=<span class="number">65537</span></span><br><span class="line">e2=<span class="number">27751</span></span><br><span class="line">e3=<span class="number">65537</span></span><br><span class="line">c1=<span class="number">5368342382489380107251269030258282008067103595899117880173297169710980852124379736420135829984131832023988667774795223808420069001078159756328642298736759964890517323144475742861501409284299556459601222657540302786301791897975932176538612601162552795835603779910738886150925504885639254302406755008796950704938463132687940418772021406619622090999564746948113296328739593309200238996686945891130656599419832796482095787039339269564880847130379179831744694000940207887150388411084465949903406848727641093033681144598595895383689139227400553234701993087147186292040330589331703587405822925483701667354935313494938769206</span></span><br><span class="line">c2=<span class="number">21521672635651854919517759696514027081496995002884626306313384597771682621826437868933822942195279941318573525337109548152966094293276717095298929811895186384560362917891928656637913236676702009205642367801075592458101830488916914437754803979953027152373619293870115731171449223105986403604973873007338969000153480949617700626516389419935352576014084068271819009465242491467427642787306345049280205827574043586767133396458785487959251540831856187380154825027964867977651727983254127239427622549059938701125498520279503972702883327594442747467858234391945790597844344295786118320620376681461727686876948563884520137741</span></span><br><span class="line">c3=<span class="number">13940747781246179701167820858098775936269078279837839169409057305686612176371099274767269714494905207551971162649902129137425806839867713157472497469542260664882313041602553845621113546259276402534229231780532278276697961222319054833980226978574905974878218905613341365260453461080117407529132948986104191917111000811731784483944945364091757083949827612260904757837644538366763161154611658652020868326985526984718638276184626634240096213703958275241215175054246685206226179114590838833694648062135027841593419815101363262701960507235056752424778384286627997500871204804629047307688466887868894491042058198480775705486</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p2 = p1 = GCD(n1,n2)</span><br><span class="line">q1 = n1//p1</span><br><span class="line">d1 = inverse(e1,(p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line">m1 = <span class="built_in">pow</span>(c1,d1,n1)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m1))</span><br><span class="line">q2 = n2//p2</span><br><span class="line">d2 = inverse(e2,(p2-<span class="number">1</span>)*(q2-<span class="number">1</span>))</span><br><span class="line">m2 = <span class="built_in">pow</span>(c2,d2,n2)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m2))</span><br><span class="line">p3 = GCD(n2,n3)</span><br><span class="line">q3 = n3//p3</span><br><span class="line">d3 = inverse(e3,(p3-<span class="number">1</span>)*(q3-<span class="number">1</span>))</span><br><span class="line">m3 = <span class="built_in">pow</span>(c3,d3,n3)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m3))</span><br><span class="line"><span class="comment">#flag&#123;G00d_w4y_tO_cR4ck_RS4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="例题-羊城杯-2021-Bigrsa"><a href="#例题-羊城杯-2021-Bigrsa" class="headerlink" title="例题  [羊城杯 2021]Bigrsa"></a>例题  [羊城杯 2021]Bigrsa</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n1 = <span class="number">103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061</span></span><br><span class="line">n2 = <span class="number">115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n1)</span><br><span class="line">c = <span class="built_in">pow</span>(c, e, n2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = %d&quot;</span> % c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解密思路：</p><p>进行了二次加密，找n1、n2的最大公因子，进行两次解密。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n1 = <span class="number">103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061</span></span><br><span class="line">n2 = <span class="number">115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264</span></span><br><span class="line"></span><br><span class="line">p = GCD(n1, n2)</span><br><span class="line">q1 = n1 // p</span><br><span class="line">q2 = n2 // p</span><br><span class="line"></span><br><span class="line">d1 = gmpy2.invert(e, (p-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line">d2 = gmpy2.invert(e, (p-<span class="number">1</span>)*(q2-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(c, d2, n2)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d1, n1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># b&#x27;SangFor&#123;qSccmm1WrgvIg2Uq_cZhmqNfEGTz2GV8&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2）低密度指数攻击"><a href="#2）低密度指数攻击" class="headerlink" title="2）低密度指数攻击"></a>2）低密度指数攻击</h2><p>e&#x3D;3或较小的值时，<font style="color:rgb(0,0,0);">由于c&#x3D;pow(m,3,n) ，因而m^3&#x3D;kn+c ，只要爆破k，使得kn+c 是一个立方数即可。</font></p><h3 id="解密思路-1"><a href="#解密思路-1" class="headerlink" title="解密思路"></a><font style="color:rgb(0,0,0);">解密思路</font></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CubeBruteforce</span>(<span class="params">c,e,n</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m = c+n*k</span><br><span class="line">        number,result = gmpy2.iroot(m,e)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">True</span> == result:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">m = CubeBruteforce(c,e,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-NSSRound-19-Basic-bestkasscn的超级简单密码"><a href="#例题-NSSRound-19-Basic-bestkasscn的超级简单密码" class="headerlink" title="例题 [NSSRound#19 Basic]bestkasscn的超级简单密码"></a>例题 [NSSRound#19 Basic]bestkasscn的超级简单密码</h3><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r = p * <span class="number">5</span> + i</span><br><span class="line">    <span class="keyword">if</span> isPrime(r):</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q = p * <span class="number">10</span> + i</span><br><span class="line">    <span class="keyword">if</span> isPrime(q):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n = p * q * r</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(flag.encode()), e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c=&#x27;</span> + <span class="built_in">str</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p3=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">pow</span>(p, <span class="number">3</span>, n)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;q3=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">pow</span>(q, <span class="number">3</span>, n)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;r3=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">pow</span>(r, <span class="number">3</span>, n)))</span><br><span class="line"><span class="comment"># n = 44571911854174527304485400947383944661319242813524818888269963870884859557542264803774212076803157466539443358890313286282067621989609252352994203884813364011659788234277369629312571477760818634118449563652776213438461157699447304292906151410018017960605868035069246651843561595572415595568705784173761441087845248621463389786351743200696279604003824362262237505386409700329605140703782099240992158439201646344692107831931849079888757310523663310273856448713786678014221779214444879454790399990056124051739535141631564534546955444505648933134838799753362350266884682987713823886338789502396879543498267617432600351655901149380496067582237899323865338094444822339890783781705936546257971766978222763417870606459677496796373799679580683317833001077683871698246143179166277232084089913202832193540581401453311842960318036078745448783370048914350299341586452159634173821890439194014264891549345881324015485910286021846721593668473</span></span><br><span class="line"><span class="comment"># c = 11212699652154912414419576042130573737460880175860430868241856564678915039929479534373946033032215673944727767507831028500814261134142245577246925294110977629353584372842303558820509861245550773062016272543030477733653059813274587939179134498599049035104941393508776333632172797303569396612594631646093552388772109708942113683783815011735472088985078464550997064595366458370527490791625688389950370254858619018250060982532954113416688720602160768503752410505420577683484807166966007396618297253478916176712265476128018816694458551219452105277131141962052020824990732525958682439071443399050470856132519918853636638476540689226313542250551212688215822543717035669764276377536087788514506366740244284790716170847347643593400673746020474777085815046098314460862593936684624708574116108322520985637474375038848494466480630236867228454838428542365166285156741433845949358227546683144341695680712263215773807461091898003011630162481</span></span><br><span class="line"><span class="comment"># p3 = 891438237083490546089708018947678893226384856270496377765399277417697191150845296075484241536063149330788867177806265725641352439792185047059884077696267280233195764685547392586251429555216372682368991273055524268769223153988946085858123028200360359212117360701384933036871231911448311911374115683475228820531478240539549424647154342506853356292956506486091063660095505979187297020928573605860329881982122478494944846700224611808246427660214535971723459345029873385956677292979041143593821672034573140001092625650099257402018634684516092489263998517027205660003413512870074652126328536906790020794659204007921147300771594986038917179253827432120018857213350120695302091483756021206199805521083496979628811676116525321724267588515105188480380865374667274442027086789352802613365511142499668793725505110436809024171752137883546327359935102833441492430652019931999144063825010678766130335038975376834579129516127516820037383067</span></span><br><span class="line"><span class="comment"># q3 = 44571911854174527304485400947383944661319242813524818888269963870884859557542264803774212076803157466539443358890313286282067621989609252352994203884813364011659788234277369629312571477760818634118449563652776213438461157699447304292906151410018017960605868035069246651843561595572415595568705784173761440671033435053531971051698504592848580356684103015611323747688216493729331061402058160819388999663041629882482138465124920580049057123360829897432472221079140360215664537272316836767039948368780837985855835419681893347839311156887660438769948501100287062738217966360434291369179859862550767272985972263442512061098317471708987686120577904202391381040801620069987103931326500146536990700234262413595295698193570184681785854277656410199477649697026112650581343325348837547631237627207304757407395388155701341044939408589591213693329516396531103489233367665983149963665364824119870832353269655933102900004362236232825539480774</span></span><br><span class="line"><span class="comment"># r3 = 22285955927087263652242700473691972330659621406762409444134981935442429778771132401887106038401578733269721679445156643141033810994804626176497101942406682005829894117138684814656285738880409317059224781826388106719230578849723652146453075705009008980302934017534623325921780797786207797784352892086880720749202442492937918619992591614713131681306874944356693778359565004415437554407990089293135634916859631279984463829118336826115430997439527110961309956466956650522900331263720500751112297418506140413317489683875995326726992533904683800042127871963320754241310699432792081707870167598822650064976439270556418985242630368723264289700246406905189810458354474959276748887369363592834205660349184660073395182450526542246354364903399132116153732074081050985584216815493617906868615192465631416955706457835185743023758573279838341229835613609332206338401219168119635681832981552328638132500079074010106995297184587143613134093145</span></span><br></pre></td></tr></table></figure><p>解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">n = <span class="number">44571911854174527304485400947383944661319242813524818888269963870884859557542264803774212076803157466539443358890313286282067621989609252352994203884813364011659788234277369629312571477760818634118449563652776213438461157699447304292906151410018017960605868035069246651843561595572415595568705784173761441087845248621463389786351743200696279604003824362262237505386409700329605140703782099240992158439201646344692107831931849079888757310523663310273856448713786678014221779214444879454790399990056124051739535141631564534546955444505648933134838799753362350266884682987713823886338789502396879543498267617432600351655901149380496067582237899323865338094444822339890783781705936546257971766978222763417870606459677496796373799679580683317833001077683871698246143179166277232084089913202832193540581401453311842960318036078745448783370048914350299341586452159634173821890439194014264891549345881324015485910286021846721593668473</span></span><br><span class="line">c = <span class="number">11212699652154912414419576042130573737460880175860430868241856564678915039929479534373946033032215673944727767507831028500814261134142245577246925294110977629353584372842303558820509861245550773062016272543030477733653059813274587939179134498599049035104941393508776333632172797303569396612594631646093552388772109708942113683783815011735472088985078464550997064595366458370527490791625688389950370254858619018250060982532954113416688720602160768503752410505420577683484807166966007396618297253478916176712265476128018816694458551219452105277131141962052020824990732525958682439071443399050470856132519918853636638476540689226313542250551212688215822543717035669764276377536087788514506366740244284790716170847347643593400673746020474777085815046098314460862593936684624708574116108322520985637474375038848494466480630236867228454838428542365166285156741433845949358227546683144341695680712263215773807461091898003011630162481</span></span><br><span class="line">p3 = <span class="number">891438237083490546089708018947678893226384856270496377765399277417697191150845296075484241536063149330788867177806265725641352439792185047059884077696267280233195764685547392586251429555216372682368991273055524268769223153988946085858123028200360359212117360701384933036871231911448311911374115683475228820531478240539549424647154342506853356292956506486091063660095505979187297020928573605860329881982122478494944846700224611808246427660214535971723459345029873385956677292979041143593821672034573140001092625650099257402018634684516092489263998517027205660003413512870074652126328536906790020794659204007921147300771594986038917179253827432120018857213350120695302091483756021206199805521083496979628811676116525321724267588515105188480380865374667274442027086789352802613365511142499668793725505110436809024171752137883546327359935102833441492430652019931999144063825010678766130335038975376834579129516127516820037383067</span></span><br><span class="line">q3 = <span class="number">44571911854174527304485400947383944661319242813524818888269963870884859557542264803774212076803157466539443358890313286282067621989609252352994203884813364011659788234277369629312571477760818634118449563652776213438461157699447304292906151410018017960605868035069246651843561595572415595568705784173761440671033435053531971051698504592848580356684103015611323747688216493729331061402058160819388999663041629882482138465124920580049057123360829897432472221079140360215664537272316836767039948368780837985855835419681893347839311156887660438769948501100287062738217966360434291369179859862550767272985972263442512061098317471708987686120577904202391381040801620069987103931326500146536990700234262413595295698193570184681785854277656410199477649697026112650581343325348837547631237627207304757407395388155701341044939408589591213693329516396531103489233367665983149963665364824119870832353269655933102900004362236232825539480774</span></span><br><span class="line">r3 = <span class="number">22285955927087263652242700473691972330659621406762409444134981935442429778771132401887106038401578733269721679445156643141033810994804626176497101942406682005829894117138684814656285738880409317059224781826388106719230578849723652146453075705009008980302934017534623325921780797786207797784352892086880720749202442492937918619992591614713131681306874944356693778359565004415437554407990089293135634916859631279984463829118336826115430997439527110961309956466956650522900331263720500751112297418506140413317489683875995326726992533904683800042127871963320754241310699432792081707870167598822650064976439270556418985242630368723264289700246406905189810458354474959276748887369363592834205660349184660073395182450526542246354364903399132116153732074081050985584216815493617906868615192465631416955706457835185743023758573279838341229835613609332206338401219168119635681832981552328638132500079074010106995297184587143613134093145</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------方法1：低密度指数攻击------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CubeBruteforce</span>(<span class="params">y</span>):</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">100</span> ):</span><br><span class="line">        <span class="keyword">if</span> gmpy2.iroot( y+n*i , <span class="number">3</span> )[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            x = gmpy2.iroot( y+n*i , <span class="number">3</span> )[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">p = CubeBruteforce(p3)</span><br><span class="line">q = CubeBruteforce(q3)</span><br><span class="line">r = CubeBruteforce(r3)</span><br><span class="line"><span class="keyword">assert</span> n == p*q*r</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p=&#x27;</span>,p,<span class="string">&#x27;\nq=&#x27;</span>,q,<span class="string">&#x27;\nr=&#x27;</span>,r)</span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#b&#x27;NSSCTF&#123;cc10786a-cc59-a07d-5c9f-df1c55b18cd4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#-------------方法2：开立方------------------</span></span><br><span class="line"><span class="string">#由于p^3小于n ，p3直接开三次方,得到p</span></span><br><span class="line"><span class="string">p=int(gmpy2.iroot(p3,3)[0])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">i = 0</span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    r = p * 5 + i</span></span><br><span class="line"><span class="string">    if isPrime(r):</span></span><br><span class="line"><span class="string">        i = 0</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        i += 1</span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    q = p * 10 + i</span></span><br><span class="line"><span class="string">    if isPrime(q):</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        i += 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">assert n == p*q*r</span></span><br><span class="line"><span class="string">print(&#x27;p=&#x27;,p,&#x27;\nq=&#x27;,q,&#x27;\nr=&#x27;,r)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">phi = (p-1)*(q-1)*(r-1)</span></span><br><span class="line"><span class="string">d = inverse(e,phi)</span></span><br><span class="line"><span class="string">m = pow(c,d,n)</span></span><br><span class="line"><span class="string">print(long_to_bytes(m))</span></span><br><span class="line"><span class="string">#b&#x27;NSSCTF&#123;cc10786a-cc59-a07d-5c9f-df1c55b18cd4&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="例题-第七题：低指数攻击"><a href="#例题-第七题：低指数攻击" class="headerlink" title="例题-第七题：低指数攻击"></a>例题-<font style="color:#080808;background-color:#ffffff;">第七题：低指数攻击</font></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">a = getPrime(<span class="number">16</span>)</span><br><span class="line">b = getPrime(<span class="number">16</span>)</span><br><span class="line">c1 = <span class="built_in">pow</span>(flag, e, n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(a*flag+b, e, n)</span><br></pre></td></tr></table></figure><p>解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">c1 = <span class="number">184706733600030961911836917506112422167545490484023895702890946835667701083139603160422181673643482375812680575389095142687410989330788033710088246782628789557043348703224329521695342998531932006194716597523162472306119232610211018033794397444557249275490146884605734496362904120178078821</span></span><br><span class="line">c2 = <span class="number">10418682562718909042213936587910449264489833039364911527081051331485882026176525975770460658763924467672782657658670208897885520552980202093589409615449950907692270444130539851619402510468945166179697778957796025706837202038217770754419639715026735344172221776217898364276354693723003323146147852444824</span></span><br><span class="line">n = <span class="number">62238551978433838001498457736429006991865583728626132139136256391485968857741649418990547571437762934449868634562245286176618471355786138381567476265484214608900167440511382125259943558246159258716213963735131393428605626773031068644321261445284230749457763679689698230585197310945795260304584991080604702929</span></span><br><span class="line">a = <span class="number">38351</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"><span class="comment">#e=3，则m^3 = kn+c1,(am+b)^3 = k`n+c2，即kn+c1是一个立方数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">c,e,n</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m = c+n*k</span><br><span class="line">        number,result = gmpy2.iroot(m,e)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">True</span> == result:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">m = de(c1,e,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#b&#x27;DASCTF&#123;aae20c7039a5b479aa8e78a8599a539e&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="例题-e-2"><a href="#例题-e-2" class="headerlink" title="例题 e&#x3D;2"></a>例题 e&#x3D;2</h3><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> shin <span class="keyword">import</span> flag</span><br><span class="line">m=bytes_to_long(flag.encode())</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=getPrime(<span class="number">256</span>)</span><br><span class="line"><span class="comment">#q=getPrime(512)</span></span><br><span class="line">q=<span class="number">6704006258427795304220450411280948926213189680360135534636452074716135019217911134480777251273836898349926894302122011679095979445240343891749741039976761</span></span><br><span class="line">r=getPrime(<span class="number">512</span>)</span><br><span class="line">n=p*q*r</span><br><span class="line">P=<span class="built_in">pow</span>(p,<span class="number">2</span>,n)</span><br><span class="line">Q=<span class="built_in">pow</span>(q,<span class="number">2</span>,n)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P = <span class="subst">&#123;P&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q = <span class="subst">&#123;Q&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">P = 6773247693445539441213578786581644136043035242620265251725630106817272212428325283262417364786451280269516220237289567904055371962564710888510272312707201</span></span><br><span class="line"><span class="string">Q = 44943699913039047357456835559925378512493523252980366265686899925123157887149890185055864945749408514100461655676474535153113631214288057465776668291975220848776401405531599573114898492452990847774628035552581539370236080368457643523158920565504112005843410442573511095306233906498204203659537135943420051121</span></span><br><span class="line"><span class="string">n = 4785613888465991171479248142015453309149548888755453367991501772592797686075465426815591528773123474962122102667475893532087343900904799831474817826058951265607078893487357878501280782935653048309499430170214015422492927323961394806106719569168457890040223027119115392961801582406287167644266319898276785787730947633037300317098453409851410936140488150390919951503767522517809035474567</span></span><br><span class="line"><span class="string">c = 2247027561636791381460194811205520085150851211795956750955965051548230844233212462525163107917067768507367576366327035846089534916090521357212722275045521111077106695721780943857231570836500588468487620819893688830570842176795906808347617421353983094639290979158413935035603633331786978227439155042365130799647385116773171906670409535157184391352888875130028955334874727206292146950544</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s</span><br><span class="line">p = gmpy2.isqrt(P)</span><br><span class="line">q = gmpy2.isqrt(Q)</span><br><span class="line">r = n // p // q</span><br><span class="line">phi = (p - <span class="number">1</span>) * (r - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, r)</span><br><span class="line">flag = n2s(<span class="built_in">int</span>(m))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># b&#x27;HDCTF&#123;0b3663ed-67e4-44e2-aee7-7c2d8665b63c&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3）低加密指数广播攻击"><a href="#3）低加密指数广播攻击" class="headerlink" title="3）低加密指数广播攻击"></a>3）低加密指数广播攻击</h2><p><font style="color:rgb(0,0,0);">e值较小，给出多组（c,n）的值ci&#x3D;m</font><sup><font style="color:rgb(0,0,0);">e</font></sup><font style="color:rgb(0,0,0);"> mod ni</font></p><h3 id="解密思路-2"><a href="#解密思路-2" class="headerlink" title="解密思路"></a><font style="color:rgb(0,0,0);">解密思路</font></h3><p><font style="color:rgb(0,0,0);">主要是利用</font><font style="color:rgb(0,0,0);">中国剩余定理</font><font style="color:rgb(0,0,0);">进行计算</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25907408/1733385426166-ad7c1489-9640-4eee-9bd5-9176d6afd96a.webp"></p><p>中国剩余定理：x&#x3D;ai mod(mi)</p><ol><li>求模数的乘积M&#x3D;m1<em>m2</em>…*m9</li><li>求每个Mi&#x3D;M&#x2F;mi</li><li>求每个ti，根据tiMi&#x3D;1(mod mi)#在sage中inverse()计算逆元，python中invert()计算</li><li>求解x，累加aitiMi</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#对照x=ai mod(mi)和给出的数据ci=me mod ni，则ai为c_list[i],mi为n_list[i]</span></span><br><span class="line">N = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n_list:</span><br><span class="line">   N *= i</span><br><span class="line"></span><br><span class="line">nn = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n_list:</span><br><span class="line">   nn.append(N // i)</span><br><span class="line"></span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">   t.append(inverse(nn[i], n_list[i]))</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n_list)):</span><br><span class="line">   x += c_list[i] * nn[i] * t[i]</span><br><span class="line">x = x % N</span><br><span class="line">x = iroot(x, <span class="number">9</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>对代码结构进行优化封装，CRT()表示中国剩余定理的运算：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRT</span>(<span class="params">mi, ai</span>):</span><br><span class="line">    <span class="keyword">assert</span>(reduce(gmpy2.gcd,mi)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(mi, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(ai, <span class="built_in">list</span>))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> <span class="built_in">zip</span>(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br><span class="line"></span><br><span class="line">m = gmpy2.iroot(CRT(n_list,c_list),e)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-NSSRound-11-Basic-MyMessage"><a href="#例题-NSSRound-11-Basic-MyMessage" class="headerlink" title="例题[NSSRound#11 Basic]MyMessage"></a>例题[NSSRound#11 Basic]MyMessage</h3><ul><li>题目：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25907408/1715667991075-9869c424-c5eb-4518-abaa-9ef4bb4294a2.webp">解题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii, gmpy2</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------ 交互部分 ------------</span></span><br><span class="line">host = <span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span></span><br><span class="line">port = <span class="number">28999</span></span><br><span class="line">conn = remote(host, port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interact_with_server</span>(<span class="params">conn</span>):</span><br><span class="line">    conn.recvuntil(<span class="string">&quot;Input message：&quot;</span>)</span><br><span class="line">    conn.sendline(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data1 = conn.recvline().decode()</span><br><span class="line">    data2 = conn.recvline().decode()</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;n: (\d+)&#x27;</span>, data1)[<span class="number">0</span>])</span><br><span class="line">    c = <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;Token: 0x(\w+)&#x27;</span>, data2)[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n, c</span><br><span class="line"></span><br><span class="line">n_values = []</span><br><span class="line">c_values = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">127</span>):</span><br><span class="line">    n, c = interact_with_server(conn)</span><br><span class="line">    n_values.append(n)</span><br><span class="line">    c_values.append(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = <span class="number">127</span></span><br><span class="line"><span class="comment"># print(&quot;n_values=&quot;,n_values)</span></span><br><span class="line"><span class="comment"># print(&quot;c_values=&quot;,c_values)</span></span><br><span class="line"><span class="comment"># ------------ 低加密指数广播攻击 ------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CRT</span>(<span class="params">mi, ai</span>):</span><br><span class="line">    <span class="keyword">assert</span>(reduce(gmpy2.gcd,mi)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(mi, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(ai, <span class="built_in">list</span>))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> <span class="built_in">zip</span>(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br><span class="line"></span><br><span class="line">e= <span class="number">127</span></span><br><span class="line">n= n_values</span><br><span class="line">c= c_values</span><br><span class="line">m=gmpy2.iroot(CRT(n, c), e)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;m=&quot;</span>,m)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment">#b&#x27;NSSCTF&#123;89f09fda-342a-4687-b1b0-ab8ae66763a4&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="4）dp-dq泄露"><a href="#4）dp-dq泄露" class="headerlink" title="4）dp dq泄露"></a>4）dp dq泄露</h2><p>已知p,q,dp,dq,c，解m</p><p>$ dp \equiv d mod{(p-1)}  $</p><p>$ dq \equiv d mod{(q-1)}  $</p><h3 id="解密思路-3"><a href="#解密思路-3" class="headerlink" title="解密思路"></a>解密思路</h3><ol><li>$ m_1 &#x3D; c^{dp} mod p $</li><li>$ m_2 &#x3D; c^{dq} mod q $</li><li>$ m &#x3D; (((m_1 - m_2)*I)mod\ p)*q +m_2 $</li><li>$ I $：乘法逆元，$ I&#x3D;invert(q,p) $</li></ol><p>利用中国剩余定理有$ m_1 \equiv c^d mod p,\ m_2 \equiv c^d mod q $</p><h3 id="例题-BUUCTF-RSA1"><a href="#例题-BUUCTF-RSA1" class="headerlink" title="例题 BUUCTF[RSA1]"></a>例题 BUUCTF[RSA1]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span></span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span></span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span></span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span></span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line"></span><br><span class="line">I = invert(q,p)            <span class="comment">#求p的逆元</span></span><br><span class="line">mp = <span class="built_in">pow</span>(c,dp,p)           <span class="comment">#求幂取模运算</span></span><br><span class="line">mq = <span class="built_in">pow</span>(c,dq,q)           <span class="comment">#求幂取模运算</span></span><br><span class="line"></span><br><span class="line">m = (((mp-mq)*I)%p)*q+mq   <span class="comment">#求明文公式</span></span><br><span class="line"><span class="comment">#m = m%n(可以加上，数值不大的话不加也没事)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n2s(<span class="built_in">int</span>(m)))              <span class="comment">#n2s()函数，用于数值转字符串</span></span><br><span class="line"><span class="comment">#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-dp泄露"><a href="#5-dp泄露" class="headerlink" title="5)dp泄露"></a>5)dp泄露</h2><p>已知e,n,c,dp，解m</p><h3 id="解密思路-爆破"><a href="#解密思路-爆破" class="headerlink" title="解密思路-爆破"></a>解密思路-爆破</h3><p>$ dp \equiv dmod(p-1) $</p><p>$ &#x3D;&gt;\ dp<em>e \equiv d</em>emod(p-1)\&#x3D;&gt;\ d<em>e \equiv k</em>(p-1)+dp*e $</p><p>根据$ \phi(n) &#x3D; (p-1)(q-1) $和$ d*e \equiv 1mod\phi(n) $得：</p><p>$ &#x3D;&gt;\ d*e \equiv 1mod(p-1)(q-1) $</p><p>变形得到：</p><p>$ k(p-1)+dp*e &#x3D; 1mod\phi(n) $</p><p>$ &#x3D;&gt;\ k_1(p-1)+dp*e &#x3D; 1mod(p-1)(q-1) $</p><p>结合：</p><p>$ k_1(p-1)+dp*e &#x3D; k_2(p-1)(q-1)+1 $</p><p>$ &#x3D;&gt;\ dp<em>e &#x3D; [k_2(p-1)(q-1)+1]-[k_1(p-1)]\&#x3D;&gt;\ dp</em>e &#x3D; [k_2(q-1)-k_1]*(p-1)+1 $</p><p>设$ X&#x3D;k_2(q-1)-k_1 $</p><p>$ &#x3D;&gt;\ dp<em>e &#x3D; X</em>(p-1)+1 $</p><p>因为$ dp&lt;p-1 $，所以$ X&lt;e\ &#x3D;&gt;X\in(0,e) $</p><p>综上得出：$ p-1&#x3D;(dp<em>e-1)&#x2F;X \ &#x3D;&gt; p&#x3D;(dp</em>e-1)&#x2F;X+1 $，且满足p能整除n $ q&#x3D;n&#x2F;&#x2F;p $</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp_force</span>(<span class="params">c,e,n,dp</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, e):</span><br><span class="line">        <span class="keyword">if</span> (e * dp % x == <span class="number">1</span>):</span><br><span class="line">            p = (e * dp - <span class="number">1</span>) // x + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (n % p != <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            q = n // p</span><br><span class="line">            phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">            d = gmpy2.invert(e, phi)</span><br><span class="line">            m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span>(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]) % <span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">m = dp_force(c,e,n,dp)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-BUUCTF-RSA2"><a href="#例题-BUUCTF-RSA2" class="headerlink" title="例题 BUUCTF[RSA2]"></a>例题 BUUCTF[RSA2]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, e):</span><br><span class="line">    <span class="keyword">if</span> (e * dp % x == <span class="number">1</span>):</span><br><span class="line">        p = (e * dp - <span class="number">1</span>) // x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n % p != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        q = n // p</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        d = gmpy2.invert(e, phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]) % <span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(m)[<span class="number">2</span>:])</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment">#flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6-爆破素数p"><a href="#6-爆破素数p" class="headerlink" title="6)爆破素数p"></a>6)爆破素数p</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    q = nextprime(q)</span><br><span class="line">    N = r**<span class="number">4</span>*q</span><br><span class="line">    d = inverse(e,(r-<span class="number">1</span>)*(q-<span class="number">1</span>)*r**<span class="number">3</span>)</span><br><span class="line">    m = long_to_bytes(<span class="built_in">pow</span>(c,d,N))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> m:</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><ol><li>题目有$ N&#x3D;r^4q $,$ c&#x3D;m^e(mod\ N) $<br>$ N&#x3D;pqr $，p是从init开始的质数累加128次的和，且p是一个立方数<br>所以$ p&#x3D;r^3 $</li><li>由于q为12位的质数，不大，可以尝试爆破，验证解密信息</li><li>计算私钥d&#x3D;inverse（e,phi）</li></ol><p>$ \phi(N)\ &#x3D;\ pqr(1-\frac{1}{p})(1-\frac{1}{q})(1-\frac{1}{r}) $</p><p>带入$ p&#x3D;r^3<br> $，有$ \phi(N)\ &#x3D;\ r^3qr(1-\frac{1}{r^3})(1-\frac{1}{q})(1-\frac{1}{r}) $<br>简化得到$ \phi(N)\ &#x3D;\ r^3(q-1)(r-1) $</p><h2 id="7-p高位攻击"><a href="#7-p高位攻击" class="headerlink" title="7)p高位攻击"></a>7)p高位攻击</h2><p>已知p的高位数</p><details class="lake-collapse"><summary id="ub8a5d090"><span class="ne-text">题目：</span></summary><p id="ue930b535" class="ne-p"><span class="ne-text">p = getPrime(512)</span></p><p id="u3954ff0d" class="ne-p"><span class="ne-text">q = getPrime(512)</span></p><p id="u650c222e" class="ne-p"><span class="ne-text">n = p*q</span></p><p id="ua891c21b" class="ne-p"><span class="ne-text">print pow(m,e,n)</span></p><p id="u47341910" class="ne-p"><span class="ne-text">print (e,n)</span></p><p id="u15d9b0d3" class="ne-p"><span class="ne-text">print p&gt;&gt;200</span></p><p id="ue40d6abc" class="ne-p"><span class="ne-text">#</span><span class="ne-text">(e,n) = (65537, 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147)</span></p><p id="u1455056f" class="ne-p"><span class="ne-text">#p_left = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902</span></p></details>### <font style="color:#000000;">解密脚本</font><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="comment">#p已知高位</span></span><br><span class="line">pl = <span class="number">7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902</span></span><br><span class="line">n = <span class="number">113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#全位数</span></span><br><span class="line">pbits = <span class="number">512</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#缺省位数</span></span><br><span class="line">kbits = pbits - pl.nbits()  <span class="comment">#nbits()位数</span></span><br><span class="line"><span class="built_in">print</span> (pl.nbits())</span><br><span class="line">pl = pl &lt;&lt; kbits</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"> </span><br><span class="line">f = x + pl</span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line">p = pl+x0</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;p: &quot;</span>, <span class="built_in">hex</span>(<span class="built_in">int</span>(p)))</span><br><span class="line"><span class="keyword">assert</span> n % p == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">312</span></span><br><span class="line"><span class="string">p:  0xda5f14bacd97f5504f39eeef22af37e8551700296843e536760cea761d334508003e01b886c0c69b4365759fb42a3faaf0c8888106bb9dbb1137769a37d191a7</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><font style="color:rgb(0,0,0);">得到p后，解RSA就行了。</font></p><h2 id="8）维纳攻击（低解密指数攻击-e很大）-小d"><a href="#8）维纳攻击（低解密指数攻击-e很大）-小d" class="headerlink" title="8）维纳攻击（低解密指数攻击-e很大）-&gt;小d"></a>8）维纳攻击（低解密指数攻击-e很大）-&gt;小d</h2><p>已知e,n，且e很大时求d</p><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><p>【D:\daydayup\MajorTools\CTF\Crytpo\维纳攻击\rsa-wiener-attack-master】</p><p>攻击脚本放在rsa-wiener-attack目录下，维纳攻击.py：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> RSAwienerHacker <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">n= <span class="number">639662333905190724963174274393118134850652056724765488685973275138948202602626008285649108873241886836533441901790252560580886492518792249844707754890068885294414947775869189660933854702732140888525369256213185908742658834741758334492843871934294115437721034834635565406377520933839418094457376057043593848401</span></span><br><span class="line">e= <span class="number">548564175098067125961375319851171259385596271876637657761522885808657855394647972481844447376596437557651275057610120865395646169671221375251081541213042646978655686531005856899936162320404991331623237305862913250487293880446994470841390688087392282045130633013139311548859962245908782253213294049851175315059</span></span><br><span class="line">c= <span class="number">266367266471585923035346980467315672043839080179258966276144775106482166900911004389808367589961536843898187180012055918063504477273067284037318171833017082239907978935274619109926579983150571298634653886980563681026116724117473808890951091279814434050754571460308728024448607359710055618866766919226511213734</span></span><br><span class="line"></span><br><span class="line">d=hack_RSA(e,n)</span><br><span class="line">flag=long_to_bytes(<span class="built_in">pow</span>(c,d,n))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="9-费马小定理"><a href="#9-费马小定理" class="headerlink" title="9) 费马小定理"></a>9) 费马小定理</h2><h3 id="题型一："><a href="#题型一：" class="headerlink" title="题型一："></a>题型一：</h3><p>c1&#x3D;pow(m,p,n)</p><p>c2&#x3D;pow(m,q,n)</p><p>解密脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sage</span><br><span class="line">c1= </span><br><span class="line">c2= </span><br><span class="line">n= </span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">PR.&lt;m&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = m^2-(c1+c2)*m+c1*c2</span><br><span class="line">x0 = f.small_roots(X=2^400)</span><br><span class="line">print(x0)</span><br><span class="line">print (long_to_bytes(int(x0[0])))</span><br></pre></td></tr></table></figure><h3 id="题型二："><a href="#题型二：" class="headerlink" title="题型二："></a>题型二：</h3><p>e &#x3D; inverse(p, (p-1)*(q-1))</p><p>根据欧拉定理可化到模p下，费马小定理有：<font style="color:#080808;background-color:#ffffff;">p &#x3D; gcd(2^e - 2, n)</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">p = gcd(<span class="built_in">pow</span>(<span class="number">2</span>, e, n) - <span class="number">2</span>, n)</span><br><span class="line">q = n // p</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-SWPUCTF-2021-新生赛-crypto3"><a href="#例题-SWPUCTF-2021-新生赛-crypto3" class="headerlink" title="例题 [SWPUCTF 2021 新生赛]crypto3"></a>例题 [SWPUCTF 2021 新生赛]crypto3</h3><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag  = &#x27;******************&#x27;</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">m1 = bytes_to_long(bytes(flag.encode()))</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">flag1 = pow(m1,p,n)</span><br><span class="line">flag2 = pow(m1,q,n)</span><br><span class="line"></span><br><span class="line">print(&#x27;flag1= &#x27;+str(flag1))</span><br><span class="line">print(&#x27;flag2= &#x27;+str(flag2))</span><br><span class="line">print(&#x27;n= &#x27;+str(n))</span><br><span class="line">#flag1= 17893542812755845772427795161304049467610774531005620109503081344099161906017295486868699578946474114607624347167976713200068059018517606363517478396368430072890681401898145302336139240273132723451063402106360810413024642916851746118524166947301681245568333254648265529408446609050354235727237078987509705857</span><br><span class="line">#flag2= 95580409405085606847879727622943874726633827220524165744517624606566789614499137069562997931972825651309707390763700301965277040876322904891716953565845966918293178547100704981251056401939781365264616997055296773593435626490578886752446381493929807909671245959154990639046333135728431707979143972145708806954</span><br><span class="line">#n= 140457323583824160338989317689698102738341061967768153879646505422358544720607476140977064053629005764551339082120337223672330979298373653766782620973454095507484118565884885623328751648660379894592063436924903894986994746394508539721459355200184089470977772075720319482839923856979166319700474349042326898971</span><br></pre></td></tr></table></figure><p>解题思路：</p><p>c1&#x3D;pow(m,p,n)&#x3D;m^p mod (p*q)</p><p>c2&#x3D;pow(m,q,n)&#x3D;m^q mod (p*q)</p><p>由费马小定理：a^(p-1)≡1(mod p)进一步推导可得a^p≡a(mod p)</p><p>则m^p≡m(mod p)，m^q≡m(mod q)，那么有</p><p>m^p&#x3D;m+k1*p</p><p>m^q&#x3D;m+k2*q</p><p>进而有</p><p>c1&#x3D;m^p mod (p<em>q)&#x3D;(m+k1</em>p) mod (p<em>q)&#x3D;m+k1</em>p+k3<em>p</em>q</p><p>c2&#x3D;m^q mod (p<em>q)&#x3D;(m+k2</em>q) mod (p<em>q)&#x3D;m+k2</em>q+k4<em>p</em>q</p><p>可以构造</p><p>c1+c2&#x3D;m+k1<em>p+k3</em>p<em>q+m+k2</em>q+k4<em>p</em>q&#x3D;2m+(k1<em>p+k3</em>p<em>q+k2</em>q+k4<em>p</em>q)</p><p>c1<em>c2&#x3D;(m+k1</em>p+k3<em>p</em>q)<em>(m+k2</em>q+k4<em>p</em>q)&#x3D;m²+(k1<em>p+k3</em>p<em>q+k2</em>q+k4<em>p</em>q)<em>m+(k1</em>p+k3<em>p</em>q)<em>(k2</em>q+k4<em>p</em>q)</p><p>(c1+c2)<em>m&#x3D;2m²+(k1</em>p+k3<em>p</em>q+k2<em>q+k4</em>p*q)*m</p><p>则有</p><p>c1<em>c2-(c1+c2)<em>m&#x3D;-m²+(k1</em>p+k3</em>p<em>q)</em>(k2<em>q+k4</em>p*q)</p><p>&#x3D;&gt;</p><p>m²-(c1+c2)<em>m+c1</em>c2&#x3D;(k1<em>p+k3</em>p<em>q)</em>(k2<em>q+k4</em>p*q)</p><p>至此，我们构成了模多项式m²-(c1+c2)<em>m+c1</em>c2</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line">c1=<span class="number">17893542812755845772427795161304049467610774531005620109503081344099161906017295486868699578946474114607624347167976713200068059018517606363517478396368430072890681401898145302336139240273132723451063402106360810413024642916851746118524166947301681245568333254648265529408446609050354235727237078987509705857</span></span><br><span class="line">c2=<span class="number">95580409405085606847879727622943874726633827220524165744517624606566789614499137069562997931972825651309707390763700301965277040876322904891716953565845966918293178547100704981251056401939781365264616997055296773593435626490578886752446381493929807909671245959154990639046333135728431707979143972145708806954</span></span><br><span class="line">n=<span class="number">140457323583824160338989317689698102738341061967768153879646505422358544720607476140977064053629005764551339082120337223672330979298373653766782620973454095507484118565884885623328751648660379894592063436924903894986994746394508539721459355200184089470977772075720319482839923856979166319700474349042326898971</span></span><br><span class="line">PR.&lt;m&gt;=PolynomialRing(Zmod(n))</span><br><span class="line">f=m^<span class="number">2</span>-(c1+c2)*m+c1*c2</span><br><span class="line">x0=f.small_roots(X=<span class="number">2</span>^<span class="number">400</span>)</span><br><span class="line"><span class="built_in">print</span>(x0)</span><br><span class="line"><span class="comment">#[1920535408007397834236393374892057067669865609963495845501]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">x0 = <span class="number">1920535408007397834236393374892057067669865609963495845501</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span>, long_to_bytes(x0))</span><br></pre></td></tr></table></figure><h3 id="例题-KPCTF-2024-初赛-ez-fermat"><a href="#例题-KPCTF-2024-初赛-ez-fermat" class="headerlink" title="例题[KPCTF 2024 初赛]ez_fermat"></a>例题[KPCTF 2024 初赛]ez_fermat</h3><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">813</span>)</span><br><span class="line">n = p * q</span><br><span class="line">d = p</span><br><span class="line">e = inverse(d, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;test_flag&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(m, e, n))</span><br></pre></td></tr></table></figure><p>分析</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/25907408/1737256443942-f06c3e59-a6b2-44a9-bc23-7748d04d04c3.png"></p><p>解密代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line">c = <span class="number">2297172673207318067644454311791059052521405524072070001463617943081937620680287073877519555417893924987805372814004437226029332185689205902364556330396100859963867726856821821201929153299863158902425114650689181400700850662495351899097507167512372167222348638943031627163322963150031484905075884684966357856735997039021272911282595603222713567742142545540368250995582560658624441813641267178033998653769097632742521154569310435572740012678651074392991522280691458449892215626597146075598152312643598829814235896873342805258450617148747956353285414172796</span></span><br><span class="line">n = <span class="number">3904054379768621006670325403570678966655298185942026071119847032293541155818374237757771677885218395571231995625009566193044227004214661252741440763224075564545575267406326084344024197161667257443366163987563451174836819677982948383967049594961135059796888603091106117040559333549933923156522162926214187395074971581109581699786654634096916190024297067217856502521108656019066292650847674105723870976455422998577177791829507752873186832882421485628003948270492309102429874674621180956748281541598316433735992507502375267828628254040129556944239703219983</span></span><br><span class="line">e = <span class="number">3346908455447174070992347616941127803725226412626643481301959623252314393488983877743239835001359838967907152394787518896740138558902876270534420306764838402995141451795721684856954259250045263865518237097216558225597879130005447703355004165638668981119439658709484546611239237700677748062521167324245405513546072909746940831890185954341722008854937777778339786187857409646068034455661780649005707291091511164030224458109751999287771088477121459794784223018351072171477613383398898036040202088356029117418211176259340287391200019380649219787316637601225</span></span><br><span class="line">p = gcd(<span class="built_in">pow</span>(<span class="number">2</span>, e, n) - <span class="number">2</span>, n)</span><br><span class="line">q = n // p</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))<span class="comment">#b’NSSCTF&#123;S0_E@z6_feRM@T_padpadpading&#125;’</span></span><br></pre></td></tr></table></figure><h2 id="10-二次剩余"><a href="#10-二次剩余" class="headerlink" title="10)二次剩余"></a>10)二次剩余</h2><p>a&#x3D;pow(p,2,r)，已知a,r求p</p><h3 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h3><p>方法一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line">r = </span><br><span class="line">a = </span><br><span class="line">R.&lt;x&gt;=PolynomialRing(Zmod(r))</span><br><span class="line">f=(x^<span class="number">2</span>)-a</span><br><span class="line">ans=f.roots()</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># a是模r的二次剩余</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = gmpy2.powmod(a, (r+<span class="number">1</span>)//<span class="number">4</span>, r)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy.ntheory.residue_ntheory <span class="keyword">import</span> nthroot_mod</span><br><span class="line">r=<span class="number">145491538843334216714386412684012043545621410855800637571278502175614814648745218194962227539529331856802087217944496965842507972546292280972112841086902373612910345469921148426463042254195665018427080500677258981687116985855921771781242636077989465778056018747012467840003841693555272437071000936268768887299</span></span><br><span class="line">a=<span class="number">55964525692779548127584763434439890529728374088765597880759713360575037841170692647451851107865577004136603179246290669488558901413896713187831298964947047118465139235438896930729550228171700578741565927677764309135314910544565108363708736408337172674125506890098872891915897539306377840936658277631020650625</span></span><br><span class="line">e2=<span class="number">2</span></span><br><span class="line"><span class="comment">#a=pow(p,2,r)</span></span><br><span class="line">p = nthroot_mod(a,e2,r,<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><h2 id="11-CopperSmith"><a href="#11-CopperSmith" class="headerlink" title="11)CopperSmith"></a>11)CopperSmith</h2><h3 id="例题-红明谷CTF-2022-easy-ya"><a href="#例题-红明谷CTF-2022-easy-ya" class="headerlink" title="例题 [红明谷CTF 2022]easy_ya"></a>例题 [红明谷CTF 2022]easy_ya</h3><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    e = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = getPrime(<span class="number">512</span>)</span><br><span class="line">            q = getPrime(<span class="number">512</span>)</span><br><span class="line">            n = p*q</span><br><span class="line">            phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">            d = inverse(e,phi)</span><br><span class="line">            <span class="keyword">return</span> p,q,d,n,e</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">p,q,d,n,e = gen()</span><br><span class="line">r = getPrime(<span class="number">512</span>)</span><br><span class="line">m = bytes_to_long(flag+os.urandom(<span class="number">32</span>))</span><br><span class="line">M = m%r</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r = %d&quot;</span>%r)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;M = %d&quot;</span>%M)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n = %d&quot;</span>%n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e = %d&quot;</span>%e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = %d&quot;</span>%c)</span><br></pre></td></tr></table></figure><p>分析：</p><p>M &#x3D; m%r –&gt;  m&#x3D;M+k*r</p><p>c &#x3D; pow(m,e,n) –&gt;  m&#x3D;(M+k*r)**e%n</p><p>–&gt; 0&#x3D;((M+k*r)**e-c)%n</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="number">7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473</span></span><br><span class="line">M = <span class="number">4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558</span></span><br><span class="line">n = <span class="number">131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (M + x*r)**e - c</span><br><span class="line">f = f.monic()</span><br><span class="line">k = f.small_roots()</span><br><span class="line">m = M + k[<span class="number">0</span>]*r</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># flag&#123;53a2e494-964d-4506-a2c4-c34b9475dedd&#125;</span></span><br></pre></td></tr></table></figure><h1 id="秘钥文件处理"><a href="#秘钥文件处理" class="headerlink" title="秘钥文件处理"></a>秘钥文件处理</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font style="color:rgb(0,0,0);">解题思路</font></h2><p><font style="color:rgb(0,0,0);">题目为.gz文件，补全后缀名.gz.tar解压后，得到key.pub文件和flag.b64文件。</font></p><ol><li><font style="color:rgb(0,0,0);">key.pub文件和flag.b64文件提取</font></li><li><font style="color:rgb(0,0,0);">使用rsa.PrivateKey(n,e,d,p,q)生成私钥priv; rsa.decrypt(c,priv)解密密文</font></li><li><font style="color:rgb(0,0,0);">base64.b64decode(cipher)进行base64解密</font></li></ol><p><font style="color:rgb(0,0,0);"></font></p><p><font style="color:rgb(0,0,0);">1. 获取key.pub密钥文件中的n和e</font></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">with open(&quot;./key.pub&quot;,&quot;rb&quot;) as file:#提取n,e</span><br><span class="line">    key = file.read()</span><br><span class="line">    pub = RSA.importKey(key)</span><br><span class="line">n = pub.n</span><br><span class="line">e = pub.e</span><br><span class="line"></span><br><span class="line">with open(&quot;./flag.b64&quot;,&quot;rb&quot;) as file:   #提取密文</span><br><span class="line">    cipher = file.read()</span><br></pre></td></tr></table></figure><p><font style="color:rgb(0,0,0);">得到n,e即可计算p,q,d</font></p><p><font style="color:rgb(0,0,0);"></font></p><p><font style="color:rgb(0,0,0);">2.</font><font style="color:rgb(0,0,0);"> </font><font style="color:rgb(0,0,0);">根据</font><font style="color:rgb(0,0,0);">n,e,d,p,q</font><font style="color:rgb(0,0,0);">即可进行</font><font style="color:rgb(0,0,0);">rsa解密：</font></p><p><font style="color:rgb(0,0,0);">import rsa</font></p><p><font style="color:rgb(0,0,0);">生产密钥</font><font style="color:rgb(0,0,0);">priv &#x3D; rsa.PrivateKey(n,e,d,p,q) </font></p><p><font style="color:rgb(0,0,0);">使用</font><font style="color:rgb(0,0,0);">rsa.decrypt(c,priv)</font><font style="color:rgb(0,0,0);">进行</font><font style="color:rgb(0,0,0);">rsa解密</font><font style="color:rgb(0,0,0);">，这里如果结果是</font><font style="color:rgb(0,0,0);">bytes类型，就需要进行decode()转化为str</font></p><p><font style="color:rgb(0,0,0);">3.</font><font style="color:rgb(0,0,0);"> </font><font style="color:rgb(0,0,0);">base64</font><font style="color:rgb(0,0,0);">解密</font><font style="color:rgb(0,0,0);">：</font></p><p><font style="color:rgb(0,0,0);">import base64</font></p><p><font style="color:rgb(0,0,0);">解密使用base64.b64decode(cipher)</font></p><p><font style="color:rgb(0,0,0);"></font></p><h3 id="例题-BUUCTF-RSA"><a href="#例题-BUUCTF-RSA" class="headerlink" title="例题 BUUCTF[RSA]"></a><font style="color:rgb(0,0,0);">例题 BUUCTF[RSA]</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.对pub.key和flag.enc处理</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">with open(&quot;pub.key&quot;,&quot;rb&quot;) as file:#提取n,e</span><br><span class="line">    key = file.read()</span><br><span class="line">    pub = RSA.importKey(key)</span><br><span class="line">n = pub.n</span><br><span class="line">e = pub.e</span><br><span class="line"></span><br><span class="line">with open(&quot;./flag.enc&quot;,&quot;rb&quot;) as file:   #提取密文</span><br><span class="line">    c = file.read()</span><br><span class="line"></span><br><span class="line">#2.根据n,e计算p,q,d</span><br><span class="line"># print(&quot;n=&quot;,n)</span><br><span class="line"># print(&quot;e=&quot;,e)</span><br><span class="line">p = 285960468890451637935629440372639283459 #分解n得到p,q</span><br><span class="line">q = 304008741604601924494328155975272418463</span><br><span class="line">import gmpy2</span><br><span class="line">d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">print(&quot;d=&quot;,d)</span><br><span class="line"></span><br><span class="line">#3.生成私钥，进行解密</span><br><span class="line">import rsa</span><br><span class="line">priv = rsa.PrivateKey(n,e,d,p,q)</span><br><span class="line">m = rsa.decrypt(c,priv).decode()    #decode()将bytes类型转化为str</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h3 id="批量解密-例题-柏鹭杯-2021-试试大数据分解"><a href="#批量解密-例题-柏鹭杯-2021-试试大数据分解" class="headerlink" title="批量解密-例题[柏鹭杯 2021]试试大数据分解?"></a>批量解密-例题[柏鹭杯 2021]试试大数据分解?</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment">#对pub.key和flag.enc处理</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;public.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:<span class="comment">#提取n,e</span></span><br><span class="line">    key = file.read()</span><br><span class="line">    pub = RSA.importKey(key)</span><br><span class="line">n = pub.n</span><br><span class="line">e = pub.e</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line"></span><br><span class="line">p = <span class="number">948539437740472240970258995719507356652939947</span></span><br><span class="line">q = <span class="number">1033916782753483187367063564275935620987269651</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d=&quot;</span>,d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enc1 = base64.b64decode(open(&#x27;flag.enc1&#x27;, &#x27;rb&#x27;).read())</span></span><br><span class="line"><span class="comment"># m1 = long_to_bytes(gmpy2.powmod(bytes_to_long(enc1), d, n))</span></span><br><span class="line"><span class="comment"># enc2 = base64.b64decode(open(&#x27;flag.enc2&#x27;, &#x27;rb&#x27;).read())</span></span><br><span class="line"><span class="comment"># m2 = long_to_bytes(gmpy2.powmod(bytes_to_long(enc2), d, n))</span></span><br><span class="line"><span class="comment"># enc3 = base64.b64decode(open(&#x27;flag.enc3&#x27;, &#x27;rb&#x27;).read())</span></span><br><span class="line"><span class="comment"># m3 = long_to_bytes(gmpy2.powmod(bytes_to_long(enc3), d, n))</span></span><br><span class="line"><span class="comment"># enc4 = base64.b64decode(open(&#x27;flag.enc4&#x27;, &#x27;rb&#x27;).read())</span></span><br><span class="line"><span class="comment"># m4 = long_to_bytes(gmpy2.powmod(bytes_to_long(enc4), d, n))</span></span><br><span class="line"><span class="comment"># print(bytes.fromhex((m1[-22:]+m2[-22:]+m3[-22:]+m4[-20:]).decode()))</span></span><br><span class="line"></span><br><span class="line">output = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    filename = <span class="string">&#x27;flag.enc&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f = f.read()</span><br><span class="line">        c = base64.b64decode(f)</span><br><span class="line">        c = bytes_to_long(c)</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        flag = long_to_bytes(m)</span><br><span class="line">        output += flag[flag.find(<span class="string">b&#x27;\x00&#x27;</span>) + <span class="number">1</span>:].decode()</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">eval</span>(<span class="string">&#x27;0x&#x27;</span> + output)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="填充文件解密"><a href="#填充文件解密" class="headerlink" title="填充文件解密"></a>填充文件解密</h2><p> 加密的时候进行了padding，导致c和n的长度一样，用pow解会出现乱码。</p><p>当密文长度和模数长度不满足RSA解密时的条件，可以尝试使用PKCS1_OAEP库求解问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line">privatekey = RSA.construct((n,e,d,p,q))</span><br><span class="line">rsakey = PKCS1_OAEP.new(privatekey)</span><br><span class="line">decrypted = rsakey.decrypt(base64.b64decode(<span class="built_in">open</span>(<span class="string">r&#x27;flag.enc&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read()))</span><br><span class="line"><span class="built_in">print</span>(decrypted)</span><br></pre></td></tr></table></figure><h3 id="例题-AFCTF-2018-可怜的RSA"><a href="#例题-AFCTF-2018-可怜的RSA" class="headerlink" title="例题 [AFCTF 2018]可怜的RSA"></a>例题 [AFCTF 2018]可怜的RSA</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./public.key&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:<span class="comment">#提取n,e</span></span><br><span class="line">    key = file.read()</span><br><span class="line">    pub = RSA.importKey(key)</span><br><span class="line">n = pub.n</span><br><span class="line">e = pub.e</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa.factor <span class="keyword">import</span> attack</span><br><span class="line">h=attack(n)</span><br><span class="line"><span class="comment"># print(h)</span></span><br><span class="line">p = <span class="number">3133337</span></span><br><span class="line">q = <span class="number">25478326064937419292200172136399497719081842914528228316455906211693118321971399936004729134841162974144246271486439695786036588117424611881955950996219646807378822278285638261582099108339438949573034101215141156156408742843820048066830863814362379885720395082318462850002901605689761876319151147352730090957556940842144299887394678743607766937828094478336401159449035878306853716216548374273462386508307367713112073004011383418967894930554067582453248981022011922883374442736848045920676341361871231787163441467533076890081721882179369168787287724769642665399992556052144845878600126283968890273067575342061776244939</span></span><br><span class="line">d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./flag.enc&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:   <span class="comment">#提取密文c</span></span><br><span class="line">    cipher = file.read()</span><br><span class="line">c = base64.b64decode(cipher)    <span class="comment">#base64解密</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line">arsa = RSA.construct((n,e,d,p,q))</span><br><span class="line">rsakey = RSA.importKey(arsa.exportKey())</span><br><span class="line">rsakey = PKCS1_OAEP.new(rsakey)</span><br><span class="line">decrypted = rsakey.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(decrypted)</span><br><span class="line"><span class="comment"># b&#x27;afctf&#123;R54_|5_$0_B0rin9&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="进阶算法"><a href="#进阶算法" class="headerlink" title="进阶算法"></a><font style="color:rgb(0,0,0);">进阶算法</font></h1><h2 id="威尔逊定理-阶乘"><a href="#威尔逊定理-阶乘" class="headerlink" title="威尔逊定理-阶乘"></a>威尔逊定理-阶乘</h2><p> 根据威尔逊定理可知：p为素数，则一定有 (p-1)! ≡ -1 (mod p)  </p><h3 id="例题-长安杯-2021-checkin"><a href="#例题-长安杯-2021-checkin" class="headerlink" title="例题 [长安杯 2021]checkin"></a>例题 [长安杯 2021]checkin</h3><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(16)</span><br><span class="line">n = p*q</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">for i in range(1,p-q):</span><br><span class="line">    m = m*i%n</span><br><span class="line">e = 1049</span><br><span class="line">print(pow(2,e,n))</span><br><span class="line">print(pow(m,e,n))</span><br><span class="line">#4513855932190587780512692251070948513905472536079140708186519998265613363916408288602023081671609336332823271976169443708346965729874135535872958782973382975364993581165018591335971709648749814573285241290480406050308656233944927823668976933579733318618949138978777831374262042028072274386196484449175052332019377</span><br><span class="line">#3303523331971096467930886326777599963627226774247658707743111351666869650815726173155008595010291772118253071226982001526457616278548388482820628617705073304972902604395335278436888382882457685710065067829657299760804647364231959804889954665450340608878490911738748836150745677968305248021749608323124958372559270</span><br></pre></td></tr></table></figure><p>分析：</p><p>由题可知：m &#x3D; (…((((flag * 1 mod n) * 2 mod n) * 3 mod n) * 4 mod n)…) * (p-q-1) mod n &#x3D; flag * (p-q-1)! mod n<br>根据威尔逊定理可知：p为素数，则一定有 (p-1)! ≡ -1 (mod p)<br>则：m * (p-q) * (p-q+1) <em>…</em> (p-1) ≡ flag * (p-1)! ≡ -flag (mod p)<br>根据乘法逆元：invert(-1, p) * (-1) ≡ 1 (mod p)<br>可知：-flag * invert(-1, p) ≡ flag (mod p)<br>那么：m * (p-q) * (p-q+1) <em>…</em> (p-1) * invert(-1, p) ≡ flag (mod p)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa.factor <span class="keyword">import</span> attack</span><br><span class="line">c2 = <span class="number">4513855932190587780512692251070948513905472536079140708186519998265613363916408288602023081671609336332823271976169443708346965729874135535872958782973382975364993581165018591335971709648749814573285241290480406050308656233944927823668976933579733318618949138978777831374262042028072274386196484449175052332019377</span></span><br><span class="line">c = <span class="number">3303523331971096467930886326777599963627226774247658707743111351666869650815726173155008595010291772118253071226982001526457616278548388482820628617705073304972902604395335278436888382882457685710065067829657299760804647364231959804889954665450340608878490911738748836150745677968305248021749608323124958372559270</span></span><br><span class="line">e = <span class="number">1049</span></span><br><span class="line"></span><br><span class="line">kn = <span class="built_in">pow</span>(<span class="number">2</span>,e) -c2</span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** <span class="number">15</span>, <span class="number">2</span> ** <span class="number">16</span>):</span><br><span class="line">    <span class="keyword">if</span> kn % q == <span class="number">0</span>:</span><br><span class="line">        p = attack(kn // q)[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">2</span>, e, p * q) == c2:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;p=&quot;</span>, p)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;q=&quot;</span>, q)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p - q, p):</span><br><span class="line">    m = m * i % p</span><br><span class="line">m = m * invert(-<span class="number">1</span>, p) % p</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span>, long_to_bytes(m))</span><br><span class="line"><span class="comment">#flag: b&quot;flag&#123;7h3_73rr1b13_7h1ng_15_7h47_7h3_p457_c4n&#x27;7_b3_70rn_0u7_by_175_r0075&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="例题-RoarCTF-2019-babyRSA"><a href="#例题-RoarCTF-2019-babyRSA" class="headerlink" title="例题 [RoarCTF 2019]babyRSA"></a>例题 [RoarCTF 2019]babyRSA</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sympy</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def myGetPrime():</span><br><span class="line">    A= getPrime(513)</span><br><span class="line">    print(A)</span><br><span class="line">    B=A-random.randint(1e3,1e5)</span><br><span class="line">    print(B)</span><br><span class="line">    return sympy.nextPrime((B!)%A)</span><br><span class="line">p=myGetPrime()</span><br><span class="line">#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span><br><span class="line">#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span><br><span class="line"></span><br><span class="line">q=myGetPrime()</span><br><span class="line">#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span><br><span class="line">#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span><br><span class="line"></span><br><span class="line">r=myGetPrime()</span><br><span class="line"></span><br><span class="line">n=p*q*r</span><br><span class="line">#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span><br><span class="line">c=pow(flag,e,n)</span><br><span class="line">#e=0x1001</span><br><span class="line">#c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由<code>威尔逊定理</code>有$ (A−1)!≡−1(modA) $</p><p>对于题目中的B!modA,我们可以补成$ (A−1)∗(A−2)∗⋯∗(B!) $</p><p>则有$ (A−1)∗(A−2)∗⋯∗(B!)≡−1(modA) $</p><p>即$ (A−2)∗⋯∗(B!)≡1(modA) $</p><p>根据威尔逊定理得到p,q，再计算r解密RSA</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> nextprime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p_q</span>(<span class="params">A,B</span>):</span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(B+<span class="number">1</span>,A-<span class="number">1</span>):</span><br><span class="line">        tmp *= i</span><br><span class="line">        tmp %= A</span><br><span class="line"></span><br><span class="line">    tmp_inv = invert(tmp,A)</span><br><span class="line">    result = nextprime(tmp_inv)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">A1=<span class="number">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class="line">B1=<span class="number">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class="line">A2=<span class="number">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class="line">B2=<span class="number">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class="line">n = <span class="number">85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class="line">e = <span class="number">0x1001</span></span><br><span class="line">c = <span class="number">75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class="line"></span><br><span class="line">p = get_p_q(A1,B1)</span><br><span class="line">q = get_p_q(A2,B2)</span><br><span class="line">r = n // p // q</span><br><span class="line"></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(powmod(c, d, n)))</span><br><span class="line"><span class="comment">#b&#x27;RoarCTF&#123;wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="解p-next-prime-zxy-，q-next-prime-z"><a href="#解p-next-prime-zxy-，q-next-prime-z" class="headerlink" title="解p&#x3D;next_prime(zxy)，q&#x3D;next_prime(z)"></a>解p&#x3D;next_prime(z<em>x</em>y)，q&#x3D;next_prime(z)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A=(((y%x)**<span class="number">5</span>)%(x%y))**<span class="number">2019</span>+y**<span class="number">316</span>+(y+<span class="number">1</span>)/x</span><br><span class="line">p=next_prime(z*x*y)</span><br><span class="line">q=next_prime(z)</span><br><span class="line">A =  <span class="number">2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724</span></span><br><span class="line">n =  <span class="number">117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127</span></span><br><span class="line">c =  <span class="number">41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 首先有A&#x3D;(((y%x)**5)%(x%y))<strong>2019+y</strong>316+(y+1)&#x2F;x<br>A已知，所以这里可以爆破ｘ和ｙ<br>然后算出z<br>然后再进行爆破p和q(要nextprime)  </p><h3 id="解密脚本-1"><a href="#解密脚本-1" class="headerlink" title="解密脚本"></a>解密脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">A = <span class="number">2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724</span></span><br><span class="line">n = <span class="number">117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127</span></span><br><span class="line">c = <span class="number">41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常解</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> x !=y <span class="keyword">and</span> (((y%x)**<span class="number">5</span>)%(x%y))**<span class="number">2019</span>+y**<span class="number">316</span>+(y+<span class="number">1</span>)//x == A:</span><br><span class="line">                z2 = n//(x*y) </span><br><span class="line">                z = nroot(z2,<span class="number">2</span>)</span><br><span class="line">                p = nextprime(z*x*y)</span><br><span class="line">                q = nextprime(z)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1000</span>,<span class="number">1000</span>):</span><br><span class="line">                        Q = q+j</span><br><span class="line">                        <span class="built_in">print</span>(j)</span><br><span class="line">                        P = n // Q</span><br><span class="line">                        <span class="keyword">if</span> P*Q == n <span class="keyword">and</span> gcd(P,Q) == <span class="number">1</span>:</span><br><span class="line">                            <span class="built_in">print</span>(P,Q)</span><br><span class="line">                            phi=(P-<span class="number">1</span>)*(Q-<span class="number">1</span>)</span><br><span class="line">                            d=inverse(<span class="number">65537</span>,phi)</span><br><span class="line">                            m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">                            <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">                            exit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对p-q-x-m-1-x-1-m-y-n-1-y-1-n求解"><a href="#对p-q-x-m-1-x-1-m-y-n-1-y-1-n求解" class="headerlink" title="对p,q&#x3D;x**(m+1)-(x+1)m, y(n+1)-(y+1)**n求解"></a>对p,q&#x3D;x**(m+1)-(x+1)<strong>m, y</strong>(n+1)-(y+1)**n求解</h2><p>参考链接<a href="https://blog.cryptohack.org/cryptoctf2020#one-line-crypto">https://blog.cryptohack.org/cryptoctf2020#one-line-crypto</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> m, n, x, y, flag</span><br><span class="line"></span><br><span class="line">p, q = x**(m+<span class="number">1</span>) - (x+<span class="number">1</span>)**m, y**(n+<span class="number">1</span>) - (y+<span class="number">1</span>)**n</span><br><span class="line"><span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> isPrime(q) <span class="keyword">and</span> p &lt; q &lt; p &lt;&lt; <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">bin</span>(p*q)[<span class="number">2</span>:]) == <span class="number">2048</span></span><br><span class="line">enc = bytes_to_long(flag)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(enc, <span class="number">0x10001</span>, p*q))</span><br></pre></td></tr></table></figure><p>$ \ p&#x3D;x^{(m+1)}-(x+1)^m\q&#x3D;y^{(n+1)}-(y+1)^n<br> $，且满足$ isprime(p)\isprime(q)\bitlength(p<em>q)&#x3D;2048\p&lt;q&lt;p</em>8<br> $</p><blockquote><p>The prime selection for <code>p</code> and <code>q</code> is identical. Two secret numbers <code>x</code> and <code>m</code> are used, such that <code>x^(m+1) - (x+1)^m</code> is a prime. Calculating <code>q</code> uses differently named constants, but there’s no cross-dependencies between the parameters.</p><p>Knowing that <code>p*q</code> contains 2048 bits, counting from the MSB, puts some rather strict bounds on the parameters. Just playing around with random numbers, it quickly becomes clear that <code>m</code>&#x2F;<code>n</code> can’t be very big.</p><p>The plan simply becomes:</p><ol><li>Start off with a low bound like 500 or 1000</li><li>Brute-force all <code>m</code> and <code>x</code> less than the bound, such that <code>x^(m+1) - (x+1)^m</code> is max 2048 bits.</li><li>When we got ourselves a small pool of candidate values, pair up two and two random values from the pool</li><li>Check if their product is 2048 bits, and try to decrypt the ciphertext.</li></ol></blockquote><p> p，q的比特长度均小于2048（应该更小）。我们可以通过这个条件来枚举xy和mn，求出该范围内的所有素数，然后再从中选取任意两个素数，p*q长度若为2048bits，则尝试解密。  </p><h3 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert, is_prime</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">primes = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> xy <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">500</span>)):</span><br><span class="line">    <span class="keyword">for</span> mn <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">        prime = xy**(mn+<span class="number">1</span>) - (xy+<span class="number">1</span>)**mn</span><br><span class="line">        <span class="keyword">if</span> prime.bit_length() &gt; <span class="number">2048</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> is_prime(prime):</span><br><span class="line">            primes.append(prime)</span><br><span class="line"></span><br><span class="line">c = <span class="number">14608474132952352328897080717325464308438322623319847428447933943202421270837793998477083014291941466731019653023483491235062655934244065705032549531016125948268383108879698723118735440224501070612559381488973867339949208410120554358243554988690125725017934324313420395669218392736333195595568629468510362825066512708008360268113724800748727389663826686526781051838485024304995256341660882888351454147057956887890382690983135114799585596506505555357140161761871724188274546128208872045878153092716215744912986603891814964771125466939491888724521626291403272010814738087901173244711311698792435222513388474103420001421</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(primes)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(primes)):</span><br><span class="line">        pq = primes[i]*primes[j]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">bin</span>(pq)[<span class="number">2</span>:]) == <span class="number">2048</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                d = invert(<span class="number">0x10001</span>, (primes[i]-<span class="number">1</span>)*(primes[j]-<span class="number">1</span>))</span><br><span class="line">                dec = long_to_bytes(<span class="built_in">pow</span>(c, d, pq))</span><br><span class="line">                <span class="keyword">if</span> <span class="string">b&quot;CCTF&quot;</span> <span class="keyword">in</span> dec:</span><br><span class="line">                    <span class="built_in">print</span>(dec)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#b&#x27;CCTF&#123;0N3_1!nE_CrYp7O_iN_202O&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="例题-长城杯-2021-院校组-baby-rsa"><a href="#例题-长城杯-2021-院校组-baby-rsa" class="headerlink" title="例题[长城杯 2021 院校组]baby_rsa"></a>例题[长城杯 2021 院校组]baby_rsa</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, v1, v2, m1, m2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_1</span>(<span class="params">val</span>):</span><br><span class="line">    p, q = <span class="built_in">pow</span>(v1, (m1+<span class="number">1</span>))-<span class="built_in">pow</span>((v1+<span class="number">1</span>), m1), <span class="built_in">pow</span>(v2, (m2+<span class="number">1</span>))-<span class="built_in">pow</span>((v2+<span class="number">1</span>), m2)</span><br><span class="line">    <span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> isPrime(q) <span class="keyword">and</span> (</span><br><span class="line">        p*q).bit_length() == <span class="number">2048</span> <span class="keyword">and</span> q &lt; p &lt; q &lt;&lt; <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(val, <span class="number">0x10001</span>, p*q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_2</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">assert</span> val.bit_length() &lt; <span class="number">512</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        fac = [getPrime(<span class="number">512</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">        <span class="keyword">if</span> isPrime(((fac[<span class="number">0</span>]+fac[<span class="number">1</span>]+fac[<span class="number">2</span>]) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>):</span><br><span class="line">            n = fac[<span class="number">0</span>]*fac[<span class="number">1</span>]*fac[<span class="number">2</span>]*(((fac[<span class="number">0</span>]+fac[<span class="number">1</span>]+fac[<span class="number">2</span>]) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    c = <span class="built_in">pow</span>(val, <span class="number">0x10001</span>, n)</span><br><span class="line">    <span class="keyword">return</span> (c, n, ((fac[<span class="number">0</span>]+fac[<span class="number">1</span>]+fac[<span class="number">2</span>]) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">assert</span> flag[:<span class="number">5</span>] == <span class="string">b&#x27;flag&#123;&#x27;</span></span><br><span class="line">    plain1 = bytes_to_long(flag[:<span class="number">21</span>])</span><br><span class="line">    plain2 = bytes_to_long(flag[<span class="number">21</span>:])</span><br><span class="line">    <span class="built_in">print</span>(enc_1(plain1))</span><br><span class="line">    <span class="built_in">print</span>(enc_2(plain2))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">15808773921165746378224649554032774095198531782455904169552223303513940968292896814159288417499220739875833754573943607047855256739976161598599903932981169979509871591999964856806929597805904134099901826858367778386342376768508031554802249075072366710038889306268806744179086648684738023073458982906066972340414398928411147970593935244077925448732772473619783079328351522269170879807064111318871074291073581343039389561175391039766936376267875184581643335916049461784753341115227515163545709454746272514827000601853735356551495685229995637483506735448900656885365353434308639412035003119516693303377081576975540948311</span></span><br><span class="line"><span class="string">(40625981017250262945230548450738951725566520252163410124565622126754739693681271649127104109038164852787767296403697462475459670540845822150397639923013223102912674748402427501588018866490878394678482061561521253365550029075565507988232729032055298992792712574569704846075514624824654127691743944112075703814043622599530496100713378696761879982542679917631570451072107893348792817321652593471794974227183476732980623835483991067080345184978482191342430627490398516912714451984152960348899589532751919272583098764118161056078536781341750142553197082925070730178092561314400518151019955104989790911460357848366016263083, 43001726046955078981344016981790445980199072066019323382068244142888931539602812318023095256474939697257802646150348546779647545152288158607555239302887689137645748628421247685225463346118081238718049701320726295435376733215681415774255258419418661466010403928591242961434178730846537471236142683517399109466429776377360118355173431016107543977241358064093102741819626163467139833352454094472229349598479358367203452452606833796483111892076343745958394932132199442718048720633556310467019222434693785423996656306612262714609076119634814783438111843773649519101169326072793596027594057988365133037041133566146897868269, 39796272592331896400626784951713239526857273168732133046667572399622660330587881579319314094557011554851873068389016629085963086136116425352535902598378739)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对前半部分进行(p*q).bit_length()&#x3D;2048爆破解密flag{</p><p>对后半部分n可分解为4个素数，直接RSA解</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa.factor <span class="keyword">import</span> attack</span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">cipher1 = <span class="number">15808773921165746378224649554032774095198531782455904169552223303513940968292896814159288417499220739875833754573943607047855256739976161598599903932981169979509871591999964856806929597805904134099901826858367778386342376768508031554802249075072366710038889306268806744179086648684738023073458982906066972340414398928411147970593935244077925448732772473619783079328351522269170879807064111318871074291073581343039389561175391039766936376267875184581643335916049461784753341115227515163545709454746272514827000601853735356551495685229995637483506735448900656885365353434308639412035003119516693303377081576975540948311</span></span><br><span class="line">cipher2 = (<span class="number">40625981017250262945230548450738951725566520252163410124565622126754739693681271649127104109038164852787767296403697462475459670540845822150397639923013223102912674748402427501588018866490878394678482061561521253365550029075565507988232729032055298992792712574569704846075514624824654127691743944112075703814043622599530496100713378696761879982542679917631570451072107893348792817321652593471794974227183476732980623835483991067080345184978482191342430627490398516912714451984152960348899589532751919272583098764118161056078536781341750142553197082925070730178092561314400518151019955104989790911460357848366016263083</span>, <span class="number">43001726046955078981344016981790445980199072066019323382068244142888931539602812318023095256474939697257802646150348546779647545152288158607555239302887689137645748628421247685225463346118081238718049701320726295435376733215681415774255258419418661466010403928591242961434178730846537471236142683517399109466429776377360118355173431016107543977241358064093102741819626163467139833352454094472229349598479358367203452452606833796483111892076343745958394932132199442718048720633556310467019222434693785423996656306612262714609076119634814783438111843773649519101169326072793596027594057988365133037041133566146897868269</span>, <span class="number">39796272592331896400626784951713239526857273168732133046667572399622660330587881579319314094557011554851873068389016629085963086136116425352535902598378739</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dnc1</span>(<span class="params">cipher1</span>):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(log(<span class="number">2</span> ** <span class="number">1021</span>, v)), <span class="built_in">int</span>(log(<span class="number">2</span> ** <span class="number">1027</span>, v))):  <span class="comment"># log(x,y)  y为底x的对数</span></span><br><span class="line">            p = <span class="built_in">pow</span>(v, m + <span class="number">1</span>) - <span class="built_in">pow</span>(v + <span class="number">1</span>, m)</span><br><span class="line">            <span class="keyword">if</span> isPrime(p) <span class="keyword">and</span> <span class="number">1021</span> &lt; <span class="built_in">len</span>(<span class="built_in">bin</span>(p)) &lt; <span class="number">1027</span>:</span><br><span class="line">                phin1 = p - <span class="number">1</span></span><br><span class="line">                d1 = inverse(e, phin1)</span><br><span class="line">                m = <span class="built_in">pow</span>(cipher1, d1, p)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;flag&#123;&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(long_to_bytes(m)):</span><br><span class="line">                    <span class="keyword">return</span> long_to_bytes(m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dnc2</span>(<span class="params">cipher2</span>):</span><br><span class="line">    c1 = cipher2[<span class="number">0</span>]</span><br><span class="line">    shift = cipher2[<span class="number">2</span>]</span><br><span class="line">    h=attack(shift)</span><br><span class="line">    phi1=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> h:</span><br><span class="line">        phi1 *= (i-<span class="number">1</span>)</span><br><span class="line">    d2 = inverse(e, phi1)</span><br><span class="line">    m = <span class="built_in">pow</span>(c1, d2, shift)</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dnc1(cipher1)+dnc2(cipher2))</span><br><span class="line"><span class="comment">#b&#x27;flag&#123;8102c552-3d78-4a42-b659-0c96ef827f05&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="已知p-bq，ap-q求解"><a href="#已知p-bq，ap-q求解" class="headerlink" title="已知p+bq，ap+q求解"></a>已知p+b<em>q，a</em>p+q求解</h2><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad_flag</span>(<span class="params">flag, bits=<span class="number">1024</span></span>):</span><br><span class="line">    pad = os.urandom(bits//<span class="number">8</span> - <span class="built_in">len</span>(flag))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(flag + pad, <span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">p,q = [getPrime(<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;RSA&quot;</span>[<span class="number">1</span>:]] </span><br><span class="line">a,b = [randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">&quot;RSA&quot;</span>[:-<span class="number">1</span>]] </span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">m = pad_flag(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> m &lt; n</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(p + b * q)</span><br><span class="line"><span class="built_in">print</span>(a * p + q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11850797596095451670524864488046085367812828367468720385501401042627802035427938560866042101544712923470757782908521283827297125349504897418356898752774318846698532487439368216818306352553082800908866174488983776084101115047054799618258909847935672497139557595959270012943240666681053544905262111921321629682394432293381001209674417203517322559283298774214341100975920287314509947562597521988516473281739331823626676843441511662000240327706777269733836703945274332346982187104319993337626265180132608256601473051048047584429295402047392826197446200263357260338332947498385907066370674323324146485465822881995994908925</span></span><br><span class="line"><span class="comment"># 21318014445451076173373282785176305352774631352746325570797607376133429388430074045541507180590869533728841479322829078527002230672051057531691634445544608584952008820389785877589775003311007782211153558201413379523215950193011250189319461422835303446888969202767656215090179505169679429932715040614611462819788222032915253996376941436179412296039698843901058781175173984980266474602529294294210502556931214075073722598225683528873417278644194278806584861250188304944748756498325965302770207316134309941501186831407953950259399116931502886169434888276069750811498361059787371599929532460624327554481179566565183721777</span></span><br><span class="line"><span class="comment"># 4780454330598494796755521994676122817049316484524449315904838558624282970709853419493322324981097593808974378840031638879097938241801612033487018497098140216369858849215655128326752931937595077084912993941304190099338282258345677248403566469008681644014648936628917169410836177868780315684341713654307395687505633335014603359767330561537038768638735748918661640474253502491969012573691915259958624247097465484616897537609020908205710563729989781151998857899164730749018285034659826333237729626543828084565456402192248651439973664388584573568717209037035304656129544659938260424175198672402598017357232325892636389317</span></span><br><span class="line"><span class="comment"># 9819969459625593669601382899520076842920503183309309803192703938113310555315820609668682700395783456748733586303741807720797250273398269491111457242928322099763695038354042594669354762377904219084248848357721789542296806917415858628166620939519882488036571575584114090978113723733730014540463867922496336721404035184980539976055043268531950537390688608145163366927155216880223837210005451630289274909202545128326823263729300705064272989684160839861214962848466991460734691634724996390718260697593087126527364129385260181297994656537605275019190025309958225118922301122440260517901900886521746387796688737094737637604</span></span><br></pre></td></tr></table></figure><p>同强网杯初赛的dpbq第三步解</p><p>脚本：<a href="https://github.com/defund/ctf/blob/master/angstromctf-2024/blahaj/solve.sage">https://github.com/defund/ctf/blob/master/angstromctf-2024/blahaj/solve.sage</a></p><h3 id="解题脚本-2"><a href="#解题脚本-2" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">hints = (</span><br><span class="line">    <span class="number">4780454330598494796755521994676122817049316484524449315904838558624282970709853419493322324981097593808974378840031638879097938241801612033487018497098140216369858849215655128326752931937595077084912993941304190099338282258345677248403566469008681644014648936628917169410836177868780315684341713654307395687505633335014603359767330561537038768638735748918661640474253502491969012573691915259958624247097465484616897537609020908205710563729989781151998857899164730749018285034659826333237729626543828084565456402192248651439973664388584573568717209037035304656129544659938260424175198672402598017357232325892636389317</span>,</span><br><span class="line">    <span class="number">9819969459625593669601382899520076842920503183309309803192703938113310555315820609668682700395783456748733586303741807720797250273398269491111457242928322099763695038354042594669354762377904219084248848357721789542296806917415858628166620939519882488036571575584114090978113723733730014540463867922496336721404035184980539976055043268531950537390688608145163366927155216880223837210005451630289274909202545128326823263729300705064272989684160839861214962848466991460734691634724996390718260697593087126527364129385260181297994656537605275019190025309958225118922301122440260517901900886521746387796688737094737637604</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">n = <span class="number">21318014445451076173373282785176305352774631352746325570797607376133429388430074045541507180590869533728841479322829078527002230672051057531691634445544608584952008820389785877589775003311007782211153558201413379523215950193011250189319461422835303446888969202767656215090179505169679429932715040614611462819788222032915253996376941436179412296039698843901058781175173984980266474602529294294210502556931214075073722598225683528873417278644194278806584861250188304944748756498325965302770207316134309941501186831407953950259399116931502886169434888276069750811498361059787371599929532460624327554481179566565183721777</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">11850797596095451670524864488046085367812828367468720385501401042627802035427938560866042101544712923470757782908521283827297125349504897418356898752774318846698532487439368216818306352553082800908866174488983776084101115047054799618258909847935672497139557595959270012943240666681053544905262111921321629682394432293381001209674417203517322559283298774214341100975920287314509947562597521988516473281739331823626676843441511662000240327706777269733836703945274332346982187104319993337626265180132608256601473051048047584429295402047392826197446200263357260338332947498385907066370674323324146485465822881995994908925</span></span><br><span class="line"></span><br><span class="line">y = hints[<span class="number">0</span>]</span><br><span class="line">x = hints[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">R = Integers(n)</span><br><span class="line"></span><br><span class="line">P.&lt;a, b, p, q&gt; = PolynomialRing(Integers(n))</span><br><span class="line"></span><br><span class="line">f1 = a * p + q</span><br><span class="line">f2 = p + b * q</span><br><span class="line">f3 = p * q</span><br><span class="line"></span><br><span class="line">I = Ideal([f1 - x, f2 - y, f3 - n])</span><br><span class="line">B = I.groebner_basis()</span><br><span class="line"></span><br><span class="line">g = B[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">z = ZZ(g.coefficient(&#123;q: <span class="number">1</span>&#125;))</span><br><span class="line"><span class="keyword">assert</span> g.constant_coefficient() == R(-y)</span><br><span class="line"></span><br><span class="line">_, (z1, _), (z2, _) = <span class="built_in">list</span>(g)</span><br><span class="line">z1 = ZZ(z1)</span><br><span class="line">z2 = ZZ(z2)</span><br><span class="line"></span><br><span class="line">S = <span class="number">2</span>**<span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p_upper_bits <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    p_upper = p_upper_bits &lt;&lt; <span class="number">1020</span></span><br><span class="line">    <span class="keyword">for</span> q_upper_bits <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        q_upper = q_upper_bits &lt;&lt; <span class="number">1020</span></span><br><span class="line">        M = matrix(ZZ, [[S, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                        [S * z1, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                        [S * (z2 + p_upper + q_upper * z1), <span class="number">0</span>, <span class="number">0</span>, S],</span><br><span class="line">                        [S * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">        B = M.LLL()</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> B:</span><br><span class="line">            <span class="keyword">if</span> b[-<span class="number">1</span>] == S:</span><br><span class="line">                <span class="keyword">if</span> b[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                    b *= -<span class="number">1</span></span><br><span class="line">                p_guess = b[<span class="number">1</span>] + p_upper</span><br><span class="line">                q_guess = b[<span class="number">2</span>] + q_upper</span><br><span class="line">                <span class="built_in">print</span>(p_guess)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> p_guess * q_guess == n:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="number">666</span>)</span><br><span class="line">                    <span class="built_in">print</span>(p_guess)</span><br><span class="line">                    <span class="built_in">print</span>(q_guess)</span><br><span class="line">                    d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, (p_guess - <span class="number">1</span>) * (q_guess - <span class="number">1</span>))</span><br><span class="line">                    message = <span class="built_in">int</span>(<span class="built_in">pow</span>(c, d, n))</span><br><span class="line">                    message_bytes = message.to_bytes((message.bit_length() + <span class="number">7</span>) // <span class="number">8</span>, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(message_bytes)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25907408/1735032285481-311e031f-6455-4368-8dcd-749f2483aae7.png"></p><h2 id="Schmidt-Samoa-密码体系"><a href="#Schmidt-Samoa-密码体系" class="headerlink" title="Schmidt-Samoa 密码体系"></a>Schmidt-Samoa 密码体系</h2><ol><li>密钥生成</li></ol><p>选取大质数p和q，并计算$ N&#x3D;p^2*q $</p><p>计算$ d&#x3D;invert(N,φ(pq)) $</p><ol start="2"><li>加密过程</li></ol><p>对于小于N的明文m，加密$ C&#x3D;m^NmodN $</p><ol start="3"><li>解密过程</li></ol><p><font style="color:rgb(77, 77, 77);">解密</font>$ m &#x3D; C^dmod\ (p*q) $</p><details class="lake-collapse"><summary id="u24e8ec50"><span class="ne-text" style="font-size: 16px">举例：</span></summary><p id="ufffbcad7" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">（1）p=7，q=11。</span></p><p id="uadba2db4" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">计算N：计算N=p²q=7²×11=539。</span></p><p id="u41b7b1ca" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">（2）计算φ(N)：φ(N)表示小于或等于N的正整数中与N互质的数的个数。对于N=p²q，有φ(N)=p(p-1)(q-1)。在我们的例子中，φ(N)=7×6×10=420。</span></p><p id="u74a6ea81" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">（3）计算d：d是N模φ(N)的逆元，即满足d×N≡1(modφ(N))。在我们的例子中，d=29（因为29×539≡1(mod420)）。</span></p><p id="ub61a109b" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">=&gt; </span><span id="pzkdI" class="ne-math" style="color: rgb(77, 77, 77); font-size: 16px"><img src="https://cdn.nlark.com/yuque/__latex/5f52b3afe4bf4ae63a03eb74294706a6.svg"></span></p><p id="uf99b2946" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">（4）加密过程：对于消息m=32，计算密文</span><span id="jnB2j" class="ne-math" style="color: rgb(77, 77, 77); font-size: 16px"><img src="https://cdn.nlark.com/yuque/__latex/55380bc1775ac4065f9be69486a4e03a.svg"></span><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">=m^539(mod 539)=373。</span></p><p id="u74b44ddb" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">（5）解密过程：计算明文</span><span id="aioIJ" class="ne-math" style="color: rgb(77, 77, 77); font-size: 16px"><img src="https://cdn.nlark.com/yuque/__latex/4c1a983076d226f46884868dc4a4b6a5.svg"></span><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">=373^29(mod 77)=32。</span></p></details><h3 id="解密思路-4"><a href="#解密思路-4" class="headerlink" title="解密思路"></a>解密思路</h3><p>由于$ N<em>d\equiv\ 1mod(p-1)</em>(q-1) $</p><p>根据欧拉定理有：$ a^{(p-1)<em>(q-1)}\equiv\ 1mod(p</em>q) $</p><p>可得：$ a^{N<em>d}&#x3D;a^{1+k</em>(q-1)(p-1)} \equiv a<em>a^{k</em>(q-1)(p-1)} &#x3D; a\ mod\ p*q $</p><p>所以$ k<em>p</em>q&#x3D;a^{N*d} -a $</p><p>$ p<em>q &#x3D; gcd(a^{N</em>d-a},N) $</p><p>因为a的取值可以是a&#x3D;2,3,4,5……  , 一般方便计算取 2  </p><p>解密：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq = gmpy2.gcd(<span class="built_in">pow</span>(<span class="number">2</span>, d* n, n) - <span class="number">2</span>, n)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,pq)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="例题-国城杯-babyRSA"><a href="#例题-国城杯-babyRSA" class="headerlink" title="例题[国城杯]babyRSA"></a>例题[国城杯]babyRSA</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;D0g3xGC&#123;****************&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">p, q</span>):</span><br><span class="line">    public_key = p*p*q</span><br><span class="line">    e = public_key</span><br><span class="line">    n = p*q</span><br><span class="line">    phi_n = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    private_key = inverse(e,phi_n)</span><br><span class="line">    <span class="keyword">return</span> public_key,private_key,e</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">N,d,e = gen_key(p,q)</span><br><span class="line"></span><br><span class="line">c = gmpy2.powmod(bytes_to_long(flag),e,N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(N)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489</span></span><br><span class="line"><span class="string">d = 58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009</span></span><br><span class="line"><span class="string">c = 82363935080688828403687816407414245190197520763274791336321809938555352729292372511750720874636733170318783864904860402219217916275532026726988967173244517058861515301795651235356589935260088896862597321759820481288634232602161279508285376396160040216717452399727353343286840178630019331762024227868572613111538565515895048015318352044475799556833174329418774012639769680007774968870455333386419199820213165698948819857171366903857477182306178673924861370469175</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>$ \phi(N)&#x3D;\phi(p<em>p</em>q)&#x3D;p(p-1)(q-1) $</p><p>由费马小定理可推出$ a^{p(p-1)(q-1)}\equiv1(mod N)<br> $</p><p>因为$ d*N\equiv\ 1(mod(p-1)(q-1)) $</p><p>所以$ a^{dN}\equiv a^{dN}(mod(p-1)(q-1))\equiv a $</p><p>所以$ a^{dN}-a\equiv 0(mod\ pq) $</p><p>因此$ pq &#x3D; gcd(a^{dN}-a,N) $</p><p>由于a是任意的数字，因此我们可以取a&#x3D;2,3,4,5…均可, 为方便起见这里取2</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">N = <span class="number">539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489</span></span><br><span class="line">d = <span class="number">58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009</span></span><br><span class="line">c = <span class="number">82363935080688828403687816407414245190197520763274791336321809938555352729292372511750720874636733170318783864904860402219217916275532026726988967173244517058861515301795651235356589935260088896862597321759820481288634232602161279508285376396160040216717452399727353343286840178630019331762024227868572613111538565515895048015318352044475799556833174329418774012639769680007774968870455333386419199820213165698948819857171366903857477182306178673924861370469175</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a = 2</span></span><br><span class="line"><span class="comment"># a_nd_a = pow(a,N*d,N)-a</span></span><br><span class="line"><span class="comment"># pq = gmpy2.gcd(a_nd_a,N)</span></span><br><span class="line">pq = gcd(<span class="built_in">pow</span>(<span class="number">2</span>,d*N,N)-<span class="number">2</span>,N)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,pq)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># b&#x27;D0g3xGC&#123;W1sh_Y0u_Go0d_L@ucK-111&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="例题-2023年浙江省赛题-类似RSA加密"><a href="#例题-2023年浙江省赛题-类似RSA加密" class="headerlink" title="例题-2023年浙江省赛题(类似RSA加密)"></a>例题-2023年浙江省赛题(类似RSA加密)</h2><p>题目：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, getRandomRange, bytes_to_long</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * (q**<span class="number">2</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">z = randrange(<span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">all</span>(<span class="built_in">pow</span>(z, (x - <span class="number">1</span>) // <span class="number">2</span>, x) == x - <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> (p, q)):</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_bit</span>(<span class="params">m, n, z</span>):</span><br><span class="line">secret = getRandomRange(<span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">pow</span>(secret, <span class="number">2</span>, n) * <span class="built_in">pow</span>(z, m, n)) % n</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:])</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">while</span> m:</span><br><span class="line">bit = m % <span class="number">10</span></span><br><span class="line">c.append(encrypt_bit(bit, n, z))</span><br><span class="line">m //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gift1=&quot;</span>, <span class="built_in">pow</span>((p + q), e, n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gift2=&quot;</span>, <span class="built_in">pow</span>((p - q), e, n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;z=&quot;</span>, z)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>, c)</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>根据gift1和gift2利用中国剩余定理CRT，可以求解(p+q)和(p-q)</li></ol><p>$ p+q\ &#x3D;\ GCD(gift1\ +\ gift2,\ n) $</p><p>$ p-q\ &#x3D;\ GCD(gift1\ -\ gift2,\ n) $</p><ol start="2"><li>根据n&#x3D;p*(q**2)，解密出p、q的值</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = GCD(gift1 + gift2, n)</span><br><span class="line">q = <span class="built_in">int</span>(gmpy2.iroot(n // p, <span class="number">2</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ol start="3"><li>每一个c进行解密</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GM_decode</span>(<span class="params">c, p, q</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(c, (p - <span class="number">1</span>) // <span class="number">2</span>, p) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">pow</span>(c, (q - <span class="number">1</span>) // <span class="number">2</span>, q) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="4"><li>将解密结果拼接，转换为字符串</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    m += <span class="built_in">str</span>(GM_decode(i, p, q))</span><br><span class="line">m = m[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="Rabin加密"><a href="#Rabin加密" class="headerlink" title="Rabin加密"></a>Rabin加密</h2><p>Rabin加密是RSA的衍生算法，e&#x3D;2是Rabin加密典型特征，但并不是所有的RSA在e&#x3D;2时都是Rabin加密。</p><h3 id="解密思路-5"><a href="#解密思路-5" class="headerlink" title="解密思路"></a>解密思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rabin_decrypt</span>(<span class="params">c, p, q, e=<span class="number">2</span></span>):  </span><br><span class="line">    n = p * q  </span><br><span class="line">    mp = <span class="built_in">pow</span>(c, (p + <span class="number">1</span>) / <span class="number">4</span>, p)  </span><br><span class="line">    mq = <span class="built_in">pow</span>(c, (q + <span class="number">1</span>) / <span class="number">4</span>, q)  </span><br><span class="line">    yp = gmpy2.invert(p, q)  </span><br><span class="line">    yq = gmpy2.invert(q, p)  </span><br><span class="line">    r = (yp * p * mq + yq * q * mp) % n  </span><br><span class="line">    rr = n - r  </span><br><span class="line">    s = (yp * p * mq - yq * q * mp) % n  </span><br><span class="line">    ss = n - s  </span><br><span class="line">    <span class="keyword">return</span> (r, rr, s, ss)</span><br></pre></td></tr></table></figure><h3 id="例题-NSSRound-11-Basic-ez-signin"><a href="#例题-NSSRound-11-Basic-ez-signin" class="headerlink" title="例题[NSSRound#11 Basic]ez_signin"></a>例题[NSSRound#11 Basic]ez_signin</h3><ul><li>题目：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25907408/1715222785575-fc76f0bf-f91e-4d37-a958-c011e2156e9d.webp"></p><ul><li>解题：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># ------------ 解密部分 ------------</span></span><br><span class="line">num1= <span class="number">62055651194144348358145412468678918401509336123073051772749762533314217619728286662371760798688561875118194544195649633242384448879072761764059916687126644473640385114519421080725018689804634101128723233072612582207308658282679098781008699599163322747691270543758403087161763369876064333324280425921394964750</span></span><br><span class="line">num2= <span class="number">18463385927321980965437726653246951796048955057073372651331605026138803420010506362085028712248654597807176458554054337080971107880547047228141364898573789458299807656255563601692821797133484879691509353646776322019514333251957397187231264561149068543659095450388878658319947968782011378805023181849449210672</span></span><br><span class="line">n= <span class="number">73539362916222270113191371841865465519917253435225388415658105684344575172199135701084682694534800712624133171924166290065152739582062755962267489737063520426601334788113555826451217510736668713394182929468109694127565908160016643914183787350344890017935641396010823351782531803619965175249542141184539851941</span></span><br><span class="line">c= <span class="number">30024064341148964888235425217110282135940435506445908151420261879511277348811019174772399290044910521135882171573543231199531126369667857084111884223543825871136391499465762557284187952734890118974484534296901621883212797627375335586213097332464996119596926917724523226221697729116156854756535487813089382386</span></span><br><span class="line">e = <span class="number">65536</span></span><br><span class="line"></span><br><span class="line">p = gcd(n,(num1 + num2 ) % n)</span><br><span class="line">q = n//p</span><br><span class="line"></span><br><span class="line">cs = [c]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rabin_decrypt</span>(<span class="params">c,p,q</span>):</span><br><span class="line">    mp = <span class="built_in">pow</span>(c, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">    mq = <span class="built_in">pow</span>(c, (q + <span class="number">1</span>) // <span class="number">4</span>, q)</span><br><span class="line"></span><br><span class="line">    yp = inverse(p,q)</span><br><span class="line">    yq = inverse(q,p)</span><br><span class="line"></span><br><span class="line">    r = (yp * p * mq + yq * q * mp) % n</span><br><span class="line">    r_ = n - r</span><br><span class="line">    s = (yp * p * mq - yq * q * mp) % n</span><br><span class="line">    s_ = n - s</span><br><span class="line">    <span class="keyword">return</span> r,r_,s,s_</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    ps = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c2 <span class="keyword">in</span> cs:</span><br><span class="line">        r,r_,s,s_ = rabin_decrypt(c2,p,q)</span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(r)</span><br><span class="line">        <span class="keyword">if</span> r_ <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(r_)</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(s)</span><br><span class="line">        <span class="keyword">if</span> s_ <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(s_)</span><br><span class="line">   <span class="comment"># print(ps)</span></span><br><span class="line">    cs = ps</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cs)):</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(cs[i]))</span><br><span class="line"><span class="comment">#b&#x27;NSSCTF&#123;b0cb081a-174b-464c-acaf-04499357c4ce&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 非对称加密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
            <tag> 大整数分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF竞赛密码学指南</title>
      <link href="/2025/01/23/CTF%E7%AB%9E%E8%B5%9B%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8C%87%E5%8D%97/"/>
      <url>/2025/01/23/CTF%E7%AB%9E%E8%B5%9B%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="All-About-Crypto-CTF竞赛密码学方向指南"><a href="#All-About-Crypto-CTF竞赛密码学方向指南" class="headerlink" title="All About Crypto - CTF竞赛密码学方向指南"></a>All About Crypto - CTF竞赛密码学方向指南</h1><p>roadicing </p><p>看雪学苑  <em>2021年09月25日 17:59</em>                                                                                          </p><p>看雪论坛作者ID：roadicing</p><p>本文最初写于2019年，旨在帮助希望在一些相对较难的CTF国际赛上解出密码学题目的同学构建一个知识框架和学习路线，近日整理了部分内容，发表在看雪论坛上，以下是本文内容（也可访问这里以PDF格式查看，排版更为清晰）。</p><p>密码学不仅是CTF竞赛中的一个重要的独立考察方向，也经常作为考点出现在其他方向的题目当中。本文从个人作为一名CTF密码学方向选手的视角入手，对需要掌握的相关内容进行整理与分析，以期帮助选手更好的学习密码学，更好的进行密码学方向题目的训练，取得更好的比赛成绩。</p><h2 id="1-扎实的数学功底"><a href="#1-扎实的数学功底" class="headerlink" title="1 扎实的数学功底"></a><strong>1 扎实的数学功底</strong></h2><p>密码分析的各个环节都离不开数学分析，对于选手求解一道CTF中的密码学方向题目来讲也是如此。在CTF中，主要考察密码学选手数论和抽象代数两个方向的数学知识。</p><h3 id="1-1-数论"><a href="#1-1-数论" class="headerlink" title="1.1 数论"></a><strong>1.1 数论</strong></h3><p>在数论方向，选手应能较为熟练的了解和掌握包括：</p><p>​整除理论（了解素数、合数、因数、倍数、整除等基本概念，掌握唯一分解定理、裴蜀定理、扩展欧几里得定理、算数基本定理等基本定理）</p><p>​同余理论（了解同余、原根、底数、指数、平方剩余、同余式、同余方程等基本概念，掌握欧拉定理、费马小定理、中国剩余定理、二次互反律、威尔逊定理等基本定理）</p><p>​连分数理论（了解连分数、无穷级数等基本概念，熟悉最佳有理数逼近、循环连分数展开、佩尔方程求解等运算过程）</p><p>​不定方程（了解低次代数曲线所对应的不定方程的基本模型，熟悉二元一次不定方程、多元一次不定方程、掌握通过代数恒等变化、不等式估算、同余法、构造法、无穷递降法等常用的不定方程求解方法）</p><p>​数论函数（了解欧拉函数、莫比乌斯函数、单位函数、恒等函数、除数函数等常用函数，掌握莫比乌斯反演、狄利克雷卷积等常用方法）</p><h3 id="1-2-抽象代数"><a href="#1-2-抽象代数" class="headerlink" title="1.2 抽象代数"></a><strong>1.2 抽象代数</strong></h3><p>在抽象代数方向，选手应能较为熟练的了解和掌握包括：</p><p>​群论（熟悉群代数结构，掌握群相关性质及其运算律）</p><p>​环论（熟悉群代数结构，掌握环相关性质及其运算律）</p><p>​域论（熟悉群代数结构，掌握域相关性质及其运算律）</p><p>​格论（熟悉格代数结构，掌握格相关性质及其运算律）</p><p>​线性代数（熟悉向量空间代数结构，掌握向量相关性质及其运算律）</p><p>  除此之外，诸如逻辑学、几何学、拓扑学、泛函分析、概率论、数理统计等其他数学分支，虽然在CTF竞赛中密码学方向题目直接考察较少，但选手应至少对其相关基本知识有一个大致了解。</p><h2 id="2-密码学技能树"><a href="#2-密码学技能树" class="headerlink" title="2 密码学技能树"></a><strong>2 密码学技能树</strong></h2><h3 id="2-1-古典密码学"><a href="#2-1-古典密码学" class="headerlink" title="2.1 古典密码学"></a><strong>2.1 古典密码学</strong></h3><p>古典密码学作为早期CTF竞赛中密码学方向的一种常见考察形式，目前已经逐渐退出国际赛的历史舞台了。 </p><p>CTF中的古典密码主要以代替（substitution）密码和置换（permutatuion）密码两种形式出现，在题目当中，出题人通常不会显式的告诉你题目所采用的加密算法，而是仅仅给出密文，预期选手通过特征检索（如密文字符集中存在标志性的特殊字符）、题目暗示（如题目名称、题目描述中出现了对加密算法的隐喻）等方式猜测出题目中可能使用的加密算法，或使用数理统计（针对密钥空间较大的代换密码，如仿射、维吉尼亚等）、爆破（针对密钥空间较小的代换或置换密码，如栅栏、移位等）等方式恢复出密钥，最后解密密文拿到FLAG。 </p><p>这类题目的难点通常不在于分析而在于猜测，因此往往难度较低，但是由于代替和置换是密码学算法中的两个最基本的操作，很多现代密码学算法中的运算都可以看作是这两种运算的复合运算，因此古典密码学题目也可作为初接触CTF竞赛密码学方向的选手的练习题目，有助于培养选手对基本运算操作的理解。</p><h3 id="2-2-现代密码学"><a href="#2-2-现代密码学" class="headerlink" title="2.2 现代密码学"></a><strong>2.2 现代密码学</strong></h3><p>现代密码学作为目前CTF竞赛中密码学方向的主要考察形式，从总体上可以分为对称密码学、非对称密码学、哈希函数和数字签名四大类题目，其中每类题目在知识点层面虽互有交集，但由于考察形式各有侧重，因此本文对这四类题目类型分别进行论述。</p><h4 id="2-2-1-对称密码学"><a href="#2-2-1-对称密码学" class="headerlink" title="2.2.1 对称密码学"></a>2.2.1 对称密码学</h4><h5 id="2-2-1-1-序列密码（流密码）"><a href="#2-2-1-1-序列密码（流密码）" class="headerlink" title="2.2.1.1 序列密码（流密码）"></a>2.2.1.1 序列密码（流密码）</h5><p>流密码通常以字节或比特为基本单位来处理信息，其密钥通常派生自一个较短的种子密钥，而派生算法一般为一个伪随机数生成算法，流密码的安全性取决于密钥流的安全性，因此CTF中的流密码类题目也主要以伪随机数生成器部分为主，当然除此之外，题目有时也会考察选手对某一具体的流密码算法的理解和分析能力，如A5&#x2F;1、RC4等。</p><p>对于伪随机数生成器来讲，常见的考察模型主要可以分为两类：</p><p>​一类为线性同余生成器（LCG），题目要求选手通过对生成器源码审计，找出设计缺陷（针对生成器参数随机化的场景）或进行数学推导恢复未知参数（针对参数恒定不变但缺失部分参数的场景），继而连续预测出接下来产生的若干个随机数，从而达到服务器要求拿到FLAG。<br>  另一类为反馈移位寄存器，其中又可分为线性反馈移位寄存器（LFSR）和非线性反馈移位寄存器（NFSR）两类主要考察模型，出题人通常会根据某一初始状态采用某种生成方法生成一份输出结果，然后将生成方法和输出结果提供给选手，预期选手还原出初始状态从而作为FLAG。</p><h5 id="2-2-1-2-分组密码（块密码）"><a href="#2-2-1-2-分组密码（块密码）" class="headerlink" title="2.2.1.2 分组密码（块密码）"></a>2.2.1.2 分组密码（块密码）</h5><p>块密码使用某一基本块为基本单位来处理信息，在加密时需要将明文数据分成若干基本块，再针对每一块进行加密，如果最后一块的长度小于基本块的长度，还需要进行padding。</p><p>目前CTF中针对块密码主要从三个角度考察：<br>  第一类是从块密码当中的ARX（A-有限域上的模加，R-循环移位，X-异或）三种基本操作入手，考察选手对组合运算的熟练程度和理解能力。<br>  第二类是从具体算法角度入手，考察AES、DES等经典加密算法（或该加密算法的自定义修改版本）的线性攻击、差分攻击、积分攻击等攻击手法和选手做密码分析的能力。<br>  第三类是从分组模式入手，考察算法在padding时（如针对PKCS5 Padding的Padding Oracle攻击）或加密模式上（如CBC字节翻转攻击、CFB重放攻击）可能会出现的问题。</p><h4 id="2-2-2-非对称密码学"><a href="#2-2-2-非对称密码学" class="headerlink" title="2.2.2 非对称密码学"></a>2.2.2 非对称密码学</h4><p>CTF竞赛中的非对称密码学主要考察三大类问题，即大整数分解问题、离散对数求解问题（包括椭圆曲线上的离散对数求解问题）和基于格（Lattice）的计算问题：</p><h5 id="2-2-2-1-大整数分解问题"><a href="#2-2-2-1-大整数分解问题" class="headerlink" title="2.2.2.1 大整数分解问题"></a>2.2.2.1 大整数分解问题</h5><p>CTF中大整数分解问题主要以RSA算法为模型进行考察，RSA在目前CTF竞赛中考察频率可以说所有考点第一位，几乎任何一场比赛都会有一道密码学题目考察RSA，根据题目中给定的RSA算法的不同场景，其攻击手法五花八门，需要选手具备很强的数论功底。 </p><p>但也正是由于RSA知识点考察过于热门，导致网上相关资料和现成的攻击脚本较为成熟，对于一些简单的RSA类题目，选手往往只需判断出该题涉及到的RSA的哪一类场景，然后根据特征去检索攻击手法即可，但对于一些国际赛上的高质量RSA类题目，仍然需要选手具备极强的分析和推导能力。目前针对RSA的常见攻击大致包括以下几类：</p><p>​针对模数的攻击：如Pollard’s p -1算法（p-1光滑）、Williams’s p + 1（p+1光滑）、试除法（|p-q|过大）、费马分解（|p-q|过小）、共模攻击、模不互素攻击等。</p><p>​针对公钥的攻击：如小公钥指数攻击、低加密指数广播攻击等。</p><p>​针对私钥的攻击：如Wiener’s attack（基于连分数）、私钥低位泄露攻击等。</p><p>​Coppersmith &amp; LLL相关攻击：如已知m高位攻击、已知p高位攻击、Coppersmith’s short-pad attack、Boneh and Durfee attack等。</p><p>​结合Oracle的攻击：有时题目当中除了提供给选手参数之外还会提供一个加密&#x2F;解密Oracle，结合Oracle可以衍生出更多种攻击形式，如针对加密Oracle的公钥泄露攻击（选择明文），针对解密Oracle的RSA LSB parity Oracle攻击（选择密文）。</p><h5 id="2-2-2-2-离散对数求解问题"><a href="#2-2-2-2-离散对数求解问题" class="headerlink" title="2.2.2.2 离散对数求解问题"></a>2.2.2.2 离散对数求解问题</h5><p>CTF中考察DLP类问题主要以Diffie–Hellman 密钥交换协议和ElGamal算法为主，要求选手能够通过审计代码找出问题关键点，并使用攻击算法求解DLP问题，常用的DLP攻击算法包括：</p><p>​小步大步法（Baby-step giant-step，中间相遇攻击的思想）</p><p>​Pollard’s Rho algorithm（基于Miller-Rabin算法，递归求解）</p><p>​Pollard’s Kangaroo algorithm（基于随机步）</p><p>​Pohlig-Hellman algorithm（针对阶n是光滑且仅有小素因子）</p><p>  </p><p>CTF中考察ECDLP类问题主要以椭圆曲线加密（ECC）为主，其曲线有限域通常为以素数为模的域 GF(p)或特征为2的域  GF(2^m)，ECDLP类题目的考察方式除了包括上面提到的DLP的一些常见模型和攻击手法的椭圆曲线版以外，也包括一些针对曲线上存在的问题的攻击形式，如：</p><p>​针对E(Fp)&#x3D;p（Frobenius轨迹t&#x3D;p+1−E(Fp)&#x3D;1）的上非正规椭圆曲线的Smart’s attack。</p><p>​针对p|q+1−E(Fq)（Frobenius轨迹t是p的倍数）的超奇异椭圆曲线的MOV攻击（借助Tate pairing或者Weil pairing）。</p><h5 id="2-2-2-3-基于格的计算问题"><a href="#2-2-2-3-基于格的计算问题" class="headerlink" title="2.2.2.3 基于格的计算问题"></a>2.2.2.3 基于格的计算问题</h5><p>CTF中考察格中的计算困难问题主要包括最近向量问题（CVP）和最短向量问题（SVP）问题，其考察形式主要分为两类：</p><p>​一类是利用格理论去分析已知的经典密码算法，如使用格基规约算法（LLL）来分析DSA签名系统（如DSA nonce  biases）、RSA加密系统（如RSA的小私钥攻击、Coppersmith相关的攻击）、背包加密系统（如Merkle–Hellman背包公钥加密算法）等。<br>  另一类是分析基于格中困难问题设而设计新的后量子密码体制，如NTRU密码系统、GGH密码系统、Gentry算法的全同态加密系统、基于LWE问题的密码系统、Ajtai–Dwork概率公钥密码系统等。  </p><p>基于格的计算问题类题目在目前CTF竞赛中频繁出现，一度成为国际赛当中的主流考点，尤其是对LLL算法的理解和使用，成为解出许多高分值题目的关键。很多时候格相关攻击较为复杂，需要选手结合论文来进行推导，关于CTF竞赛中的论文问题会在后面的章节具体阐述。</p><h4 id="2-2-3-数字签名"><a href="#2-2-3-数字签名" class="headerlink" title="2.2.3 数字签名"></a>2.2.3 数字签名</h4><p>数字签名主要用于对数字消息进行签名，主要用于防止消息被冒名伪造、篡改，以及通信双方的身份鉴别。由于数字签名主要依赖于非对称密码算法，因此CTF当中考察数字签名类题目也主要依托非对称密码体系来进行设计，常见的包括RSA签名、ElGamal签名、DSA签名、针对某一特定椭圆曲线的ECC签名等，题目模型通常为要求我们提供某一特定字符串的签名，如果能正确通过验证则提供给选手FLAG，针对数字签名类题目的攻击我们一般从三个角度来切入：</p><p>​设法直接计算私钥，比如参数值过小或曲线选择不合适，导致私钥可以被直接计算出来（如2019 ASIS CTF Quals-Halloween Party题目，给定y坐标求x坐标，计算2在模P.order()上的逆并将结果乘2*P直接得到P）。</p><p>​设法恢复私钥，即通过若干特殊明文签名对，采用建立方程等方式重构出密钥（如2019 DEFCON CTF Quals-Tania题目，通过LLL算法和Babai最近平面算法恢复出密钥）。</p><p>​设法伪造签名，即在不知道私钥的情况下，直接构造出特定字符串的签名来拿到FLAG（如2019 RealWorld CTF-bank题目，通过rogue-key attack伪造Schnorr比特币签名算法的银行提款签名）。</p><h4 id="2-2-4-哈希函数"><a href="#2-2-4-哈希函数" class="headerlink" title="2.2.4 哈希函数"></a>2.2.4 哈希函数</h4><p>CTF中考察哈希函数类问题主要以两类场景进行展开：</p><p>一类是哈希碰撞类场景，常见的攻击类型包括：</p><p>​同谋碰撞攻击：生成任意两个不同的消息和x和y，使得哈希值f(x)&#x3D;f(y)</p><p>​第二原像攻击：给定任意一个x及其哈希值f(x)，可以生成一个与之不同的y使得哈希值f(x)&#x3D;f(y)</p><p>​相同前缀攻击：给定任意一个前缀p，可以生成两个不同的后缀和x和y，使得哈希值f(p+x)&#x3D;f(p+y)</p><p>​选择前缀攻击：给定任意两个不同的前缀p和q，可以生成两个不同的后缀x和y，使得哈希值f(p+x)&#x3D;f(q+y)</p><p>在考察形式上，题目通常会直接要求选手向服务器提交A、B两个输入，如果满足AB但HASH(A)&#x3D;HASH(B)，则判断碰撞成功。HASH碰撞类题目虽然场景简单，但通常题目难度较大，而且很多时候都是出题人魔改之后的哈希算法，因此要求选手具备较强的分析能力，在攻击上多以考察代数攻击为主，如：</p><p>​利用small capacity parameter误用问题构造SHA3 Keccak海绵结构碰撞（2019 0CTF&#x2F;TCTF Quals-babysponge）</p><p>​利用Petit-Lauter攻击构造超奇异同构图上Charles-Goren-Lauter哈希函数的弱实例碰撞（2017 HXP CTF-categorical）</p><p>  </p><p>另一类则是哈希伪造场景，虽然很多时候伪造哈希也可以通过寻找碰撞的方式来实现，但是它和碰撞场景下的考察侧重点通常不同，一种典型的攻击手法即哈希长度扩展攻击，即在已知的值和的长度的情况下（这里的值未知，即代表哈希时的salt），要求选手对于任意一个的值。对于哈希伪造的场景，我们的重点一般直接从攻击手法入手，而不需要对源码进行审计（绝大多数情况下，这类场景也不会给出哈希算法细节，而是直接调用现成的MD5、SHA1库函数）。</p><h2 id="3-读paper的能力"><a href="#3-读paper的能力" class="headerlink" title="3 读paper的能力"></a><strong>3 读paper的能力</strong></h2><p>自2018年起，大量论文题开始登上CTF历史舞台，然而一场标准的CTF国际赛通常为48小时，留给选手的分析时间是有限的，因此对于很多国际赛上的密码分析类题目来讲，选手是很难在短时间内提出一种可行的攻击手段的。这个时候，就需要快速提炼出题目当中的模型、场景等关键内容，然后去检索并阅读与之对应的会议、期刊论文，从中寻找攻击思想或手段。因此，选手的论文阅读理解能力（尤其是英文文献的阅读能力）对于密码学方向来讲就显得尤为重要。近年来国际赛当中CTF题目与学术界论文或研究成果联系紧密，如：</p><p>​2018 PlaidCTF-braid题目，考察选手通过阅读论文[1]，解决一个辫子群（Braid Group）下的 Conjugacy Search 问题。</p><p>​2018 Hack.lu CTF- Escape the grid题目，考察选手通过阅读论文[2]，攻破一个使用了非安全函数产生仿射变换的 rasta 密码系统。</p><p>​2019 0CTF&#x2F;TCTF Quals-zer0lfsr题目，考察选手通过通过阅读论文[3]，利用Fast Correlation  Attack恢复出一个Meier-Staffelbach模型下0.75相关性的3个LFSR的初始状态（虽然这道题在当时比赛时被z3非预期了）。</p><p>​2019 PwnThyBytes CTF-Wrong Ring题目，考察选手通过阅读论文[4]，通过将环上带误差学习（RLWE）样本转化为多项式带误差学习(PLWE)样本，攻击一个（non-dual）RLWE的实例来求私钥。</p><p>  </p><p>还有很多题目直接以某一论文或研究成果为背景进行设计，如：</p><p>2017 ASIS CTF Final-Marijuana</p><p>  2017年5月，Divesh Aggarwal等学者提出了一种基于梅森素数的公钥密码体系[5]，2个月后，该密码系统被Marc  Beunardeau等学者攻破，相关成果以论文形式发表[6]，同年9月，该事件以CTF形式出现在当年的ASIS  CTF竞赛当中，预期选手通过阅读论文使用随机划分和LLL攻击攻破密码系统。</p><p>2017 HXP CTF-notsosmart</p><p>  2017年2月，马萨里克大学的Matus Nemec和Marek Sys等学者发现英飞凌科技提供的RSALib库中的密钥生成算法存在漏洞，并据此提出了一种可行的RSA  ROCA攻击。同年11月，相关攻击细节以论文形式披露[7]（该攻击同步影响了TPM 1.2, 4.3.5版本前的YubiKey  4等产品，CVE编号：CVE-2017-15361），两周后，该事件以CTF形式出现在当年的HXP  CTF竞赛当中，预期选手通过阅读论文使用ROCA攻击攻破一个RSA密钥生成算法。</p><h2 id="4-扎实的编程功底"><a href="#4-扎实的编程功底" class="headerlink" title="4 扎实的编程功底"></a><strong>4 扎实的编程功底</strong></h2><p>对于绝大多数情况下，当选手通过审计源码或者阅读论文整理出一种攻击手段之后，接下来都需要通过编程的方式写一个solver或exp来计算出你所需要的数据或实现你的攻击方式，这个时候就需要选手具备良好的编程功底，因为很多时候将复杂的数学模型转化成可行的脚本并不是一件容易的事。<br>这里所提到的编程主要可以看成两个部分：<br>  一类是使用python、C&#x2F;C++等这类语言进行编程，它是我们主要使用的编程语言，我们通过代码来描述我们的攻击过程，继而实现攻击。<br>  第二类是针对某一工具的编程，常用的包括SageMath、MatLab、Mathematica编程等，这一类的编程往往起到的不是描述而是计算或辅助绘图的作用，帮助我们更好的完成解题过程。其中尤其以SageMath最为常用，如针对群、环、域等代数结构的计算，在SageMath中都可以很方便的进行操作，而不需要进行代数结构的二次描述，另外很多常用算法都以内置函数的形式在SageMath当中集成，可以很方便的供选手使用。</p><h2 id="5-值得关注的CTF"><a href="#5-值得关注的CTF" class="headerlink" title="5 值得关注的CTF"></a><strong>5 值得关注的CTF</strong></h2><p>由于CTF竞赛中专职密码学方向的选手通常较少，因此一场比赛是否有较高质量的密码学题目其实往往取决于办比赛的战队中有没有一个优秀的密码学选手，目前有一些比赛的密码学题目质量是要远高于其他竞赛的，值得参赛选手去重点关注（另外有一些战队虽然拥有很强的密码学选手，但是战队办比赛较少，可以关注其每次比赛赛后发布的writeup来了解其做题时的一些思路和解法）：</p><p>Teaser Dragon CTF（波兰Google安全团队Dragon Sector战队主办）</p><p>0CTF&#x2F;TCTF （中国腾讯安全A0E战队主办）</p><p>HXP CTF （德国慕尼黑工业大学HXP战队主办）</p><p>ASIS CTF &amp; Crypto CTF （伊朗谢里夫理工大学ASIS战队主办）</p><p>CODE BLUE CTF （日本联合战队binja主办）</p><p>PlaidCTF （美国卡耐基梅隆大学PPP战队主办）</p><p>Midnight Sun CTF （瑞典HackingForSoju战队主办）</p><p>SpamAndFlags Teaser CTF （匈牙利布达佩斯技术与经济大学!SpamAndHex战队主办）</p><p>PwnThyBytes CTF （罗马尼亚PwnThyBytes战队主办）</p><h2 id="6-不只是CTF"><a href="#6-不只是CTF" class="headerlink" title="6 不只是CTF"></a><strong>6 不只是CTF</strong></h2><p>对于一名密码学方向的CTF选手来讲，除了通过活跃于各大CTF比赛和在平时保持足够的CTF题目训练强度来提升自己的水平之外，实际上还有一些其他的密码学相关竞赛可以用来作为训练，每年诸如NSU CRYPTO、WhibOx Contest等解题类密码学竞赛，也可以参加或做赛后练习用，以此来锻炼密码分析能力。</p><h2 id="7-对密码学的热情"><a href="#7-对密码学的热情" class="headerlink" title="7 对密码学的热情"></a>7 对密码学的热情</h2><p>兴趣因素放在本文最后一个环节进行论述，但是实际上这是学习密码学的第一步，也是最重要的一步，拥有对探索密码学领域的无限热情，会使你比任何人都更有可能成为一名优秀的CTF密码学选手。</p><h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8 参考文献"></a><strong>8 参考文献</strong></h2><p>[1] Ko, K.H., &amp; Lee, J.W. (2006). A fast algorithm to the conjugacy problem on generic braids.</p><p>[2] Dobraunig C. et al. (2018) Rasta: A Cipher with Low ANDdepth and Few  ANDs per Bit. In: Shacham H., Boldyreva A. (eds) Advances in Cryptology – CRYPTO 2018. CRYPTO 2018. Lecture Notes in Computer Science, vol 10991. Springer, Cham</p><p>[3] Meier W. (2011) Fast Correlation Attacks: Methods and Countermeasures.  In: Joux A. (eds) Fast Software Encryption. FSE 2011. Lecture Notes in  Computer Science, vol 6733. Springer, Berlin, Heidelberg</p><p>[4] Elias Y., Lauter K.E., Ozman E., Stange K.E. (2015) Provably Weak  Instances of Ring-LWE. In: Gennaro R., Robshaw M. (eds) Advances in  Cryptology – CRYPTO 2015. CRYPTO 2015. Lecture Notes in Computer  Science, vol 9215. Springer, Berlin, Heidelberg</p><p>[5] Aggarwal D., Joux A., Prakash A., Santha M. (2018) A New Public-Key  Cryptosystem via Mersenne Numbers. In: Shacham H., Boldyreva A. (eds)  Advances in Cryptology – CRYPTO 2018. CRYPTO 2018. Lecture Notes in  Computer Science, vol 10993. Springer, Cham</p><p>[6] Beunardeau M., Connolly A., Géraud R., Naccache D. (2019) On the  Hardness of the Mersenne Low Hamming Ratio Assumption. In: Lange T.,  Dunkelman O. (eds) Progress in Cryptology – LATINCRYPT 2017. LATINCRYPT  2017. Lecture Notes in Computer Science, vol 11368. Springer, Cham</p><p>[7] Matus Nemec, Marek Sys, Petr Svenda, Dusan Klinec, Vashek Matyas, The  Return of Coppersmith’s Attack: Practical Factorization of Widely Used  RSA Moduli, Proceedings of the 2017 ACM SIGSAC Conference on Computer  and Communications Security, October 30-November 03, 2017, Dallas,  Texas, USA [doi&gt;10.1145&#x2F;3133956.3133969]</p><p>*<em>看雪ID：roadicing ** <a href="https://bbs.pediy.com/user-home-773104.htm">https://bbs.pediy.com/user-home-773104.htm</a></em></p><p>本文由看雪论坛 roadicing 原创，转载请注明来自看雪社区![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p><p>官网：<a href="https://www.bagevent.com/event/6334937">https://www.bagevent.com/event/6334937</a></p><p>公众号ID：ikanxue</p><p>官方微博：看雪安全</p><p>商务合作：<a href="mailto:&#x77;&#115;&#99;&#64;&#x6b;&#x61;&#110;&#120;&#117;&#101;&#x2e;&#99;&#x6f;&#x6d;">wsc@kanxue.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署</title>
      <link href="/2025/01/22/%E9%83%A8%E7%BD%B2/"/>
      <url>/2025/01/22/%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>部署参考链接：<a href="https://blog.csdn.net/lang_xw/article/details/143050877">https://blog.csdn.net/lang_xw/article/details/143050877</a></p><p>使用命令：</p><ul><li><p>安装：npm install -g hexo-cli</p><ul><li>报错的话，就换源：npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></li></ul></li><li><p>hexo init    &#x2F;&#x2F;初始化</p></li><li><p>hexo clean&#x2F;&#x2F;清除缓存</p></li><li><p>hexo g   &#x2F;&#x2F;生成静态文件</p></li><li><p>hexo s    &#x2F;&#x2F;启动服务预览</p></li><li><p>hexo d    &#x2F;&#x2F; 部署到服务上</p></li></ul><p>框架主题：git clone <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;">git@github.com</a>:yelog&#x2F;hexo-theme-3-hexo.git</p><p>框架使用参考：<a href="https://yelog.org/2017/03/23/3-hexo-instruction/">https://yelog.org/2017/03/23/3-hexo-instruction/</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
